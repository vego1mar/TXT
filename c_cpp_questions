*** [C++] subtyping and subclassing ***
**Subclassing** refers to the formation of new types by inheriting from another. In C++ it is called 'derivation' and 'derived class'.

**Subtyping** refers to the possibility to use values of the subtype in places where values of the type are expected. In C++ there is no strict mechanism for subtyping, however we can consider public inheritance, overriding virtual functions (polymorphism).

Subclasses are internal (code reuse inside classes), subtypes are external (polymorphism). [in academic terminology]



*** [C++] std::unique_ptr and std::make_unique ***
The motivation behind std::make_unique:
(1) is safe for creating temporaries (do not use unnamed temporaries, because there is no way to delete them afterwards)
(2) the current rule is to 'never use new', the old rule was to 'never use new except when you make a std::unique_ptr'
(3) does not require redundant type usage

foo(make_unique<T>());          // exception safe
foo(unique_ptr<T>(new T()));    // there is new, but no delete
unique_ptr<T>(new T())          // equivalent to make_unique<T>()



*** [C++] class and struct ***
The difference between classes and structs.

From the practical point of view:
* class members are private by default, struct members are public by default

Additionally, from the technical point of view:
* class inheritance is private by default, struct inheritance is public by default
* class construction exists by default, struct construction is absent by default
* class is built upon struct, struct is built from scratch

Also, there are other differences that you may or may not take into consideration:
* class keyword can be used to declare template parameters, while struct keyword cannot
* class can be seen as closed entity, struct can be seen as a pile of bytes
* class represents custom data type, struct represents data structure (especially POD)
* class is about code (i.e. API), struct is about data (i.e. bunch of params)



*** [C++] aggregates ***
C++03 definition: 'An aggregate is an array or a class with no user-declared constructors, no private or protected non-static data members, no base classes, and no virtual functions.'

Implications:
* implicit constructors are allowed
* any static data members are allowed
* user-defined operators, especially copy-assignment, and destructor are allowed
* an array is an aggregate even if it is an array of non-aggregate class type
* aggregates can be initialized with curly braces

Aggregates vs PODs:
* PODs are aggregates with a stricter set type (subtype)
* static members doesn't matter
* reinterpret_cast<T*> to POD member type T is safe

class NotAggregate {
    int x;                             // private by default
};

class Aggregate {
public:
    NotAggregate member;
    Aggregate& operator=(Aggregate const & rhs) {}
private:
    void f() {}
};

struct POD {
    int x;
    char y;
    void f() {}
    static std::vector<char> v;        // any static does not matter
};

struct AggregateButNoPOD {
    int x;
    ~AggregateButNoPOD() {}            // user-defined destructor
};



*** [C] POD (Plain Old Data) ***
In short: an aggregation (an aggregate definition subset) of intrinsic types (built-in primitives) or intrinsic types themselves. POD type guarantees that there will be no 'magic' going on in the structure (constructors, hidden pointers etc.).

Intentions behind C++98 POD definition:
* if you compile C struct in C++, you should get equivalent to what you had in C (standard)
* it will only ever need to use static initialization (trivial)

// static initialization, upon data creation, compile-time
// dynamic initialization, object construction takes place, run-time


POD characteristics:
* is a type that is compatible with C and is compatible with certain ABI optimizations
* begins its lifetime when it obtains storage with proper size for its type
* its lifetime ends when the storage is either reused or deallocated
* a looser definition allows for constructors, yet still prohibits any virtual things
* inheritance is allowed, but polymorphism, subtyping, overloading etc. are not
* the type trait std::is_pod will be deprecated in C++20 (POD is now an equivalent to trivial type and standard layout structure)
*** standard layout type refers to layout as in C
*** trivial refers to static initialization
* POD-classes, POD-unions, scalar types, and arrays of such types are collectively called POD-types
* you can safely copy POD objects with memcpy()
*** it is guaranteed that there will be no size padding
*** static data members doesn't matter because they reside in a different memory block
*** functions are allowed since they don't make alterations to the POD size
*** we don't want virtual things since this provides hidden internal pointers
*** we don't want copy construction to be closer to C


struct POD {             // trivial, standard-layout
    int i;
    int j;
};

struct SL {              // not trivial, standard-layout
    int i;               // custom destructor
    int j;
    ~SL();
};

struct T {               // trivial, non-standard-layout
    int i;               // different access control for non-static member
private:
    int j;
};

struct N {               // not trivial, non-standard-layout
    int i;               // has custom destructor
    int j;               // has virtual function
    virtual ~N();
};

	
What can be a POD?
* int, char, wchar_t, bool, float, double, with or without long, short, signed, unsigned specifiers
* pointers to resource, pointers to function, pointers to member
* enum
* cv-qualified POD (const-volatile)
* class, struct, union of PODs, if all non-static data members are public, it has no base class, no constructors, destructors, virtual methods
* since new POD definition (C++0x) private members are allowed
* since TC1 pointers to members are allowed (forbidden up to C++98)


New definition from C++0x: 'A POD struct is a class that is both a trivial class and a standard-layout class, and has no non-static data members of type non-POD struct, non-POD union (or array of such types). (...) A POD class is a class that is either a POD struct or a POD union.'

Trivial type: a type whose storage is contiguous (trivially copyable) and which only supports static default initialization (trivially default constructible), either cv-qualified or not.

Trivial class: class, struct, union that is both trivially constructible and trivially copyable, which implies that:
* uses the implicitly defined default, copy and move constructors, copy and move assignments, and destructor
* has no virtual members
* has no non-static data members with brace- or equal- initializers
* its base class and non-static data members (if any) are themselves also trivial types

Standard layout class:
* has no non-static data members of type non-standard-layout class (or array of such types) or reference
* has no virtual functions and no virtual base classes
** has the same access control for all non-static data members
* has no non-standard-layout base classes
* either has no non-static data members in the most-derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and
* has no base classes of the same type as the first non-static data member



*** [C] default arguments promotions ***
C99 standard, 6.5.2.2: 'Function calls', paragraphs 6, 7, 8:
* if the expression that denotes the called function has a type that does not include a prototype, the integer promotions are performed on each argument, and arguments that have type float are promoted to double. These are called the default argument promotions
* if the number of arguments does not equal the number of parameters, the behavior is undefined
* if the function is defined with a type that includes a prototype, and either the prototype ends with an ellipsis (, ...) or the types of the arguments after promotion are not compatible with the types of the parameters, the behavior is undefined
* if the function is defined with a type that does not include a prototype, and the types of the arguments after promotion are not compatible with those of the parameters after promotion, the behavior is undefined, except for the following cases:
*** one promoted type is a signed integer type, the other promoted type is the corresponding unsigned integer type, and the value is representable in both types
*** both types are pointers to qualified or unqualified versions of a character type or void
* if the expression that denotes the called function has a type that does include a prototype, the arguments are implicitly converted, as if by assignment, to the types of the corresponding parameters, taking the type of each parameter to be the unqualified version of its declared type
* the ellipsis notation in a function prototype declarator causes argument type conversion to stop after the last declared parameter. The default argument promotions are performed on trailing arguments
* no other conversions are performed implicitly; in particular, the number and types of arguments are not compared with those of the parameters in a function definition that does not include a function prototype declarator

char, short                               int
unsigned char, unsigned short             unsigned int
float                                     double

void func(int a, char b, float c);        // declaration + prototype
void func(int a, char b, float c) {}      // definition + prototype
void func();                              // declaration - prototype
void func(a, b, c)                        // definition - prototype
    int a;
    char b;
    float c;
{}


Where default argument promotions are used? 
** when the expected type of the argument is unknown
* non-variadic parameters to functions with a prototype
* parameters to functions without prototype
* variadic parameters

void f(char c)           // prototyped function definition
{ printf("%c", c); }

void f();                // non-prototyped function declaration

int main() {
    f('x');              // int will be passed, char is expected
}


void f(c)                // non-prototyped function definition
char c;                  // old fashioned way, K&R style
{ printf("%c", c); }

void f(char c);          // prototyped function declaration

int main() {
    f('x');              // char will be passed, int is expected
}


Why things are this way? Before 1988, there was no such thing as a function prototype in classic 'K&R' C (Kernighan & Ritchie), so default argument promotions were instituted because:
* it was a 'free' solution (another byte or word in a register)
* to cut down on potential errors in parameter passing (which never quite cut it)



*** [C++] Unicode case ***
std::byte - multiple null-byte terminators '\0' and so on, C++17
std::string - based on char, can express ASCII characters (numbers from 0 to 127)
std::wstring - based on wchar_t, can express wide characters (1 or 2 numbers per glyph)
Unicode - has no strict representation in C++

wchar_t: 
(1) is fixed-width ANSI/ISO C implementation for wide characters
(2) is system-dependent, size of this type is compiler-specific (it is 1 B at least)
(3) it shouldn't be used for storing Unicode since it's not portable across C/C++ compilers
(4) is intended for storing compiler-defined wide characters, which may be Unicode ones
(5) usually, on Linux its width is 4 B, UTF-32, regardless of the locale
(6) usually, on Windows its width is 2 B, UTF-16, locale is relevant

Need to know:
a C++ program will use Unicode if an environment will be set up to UTF-8, yet I'd say this is not guaranteed
in terms of object marshalling issues (serialization, XML etc.) you should encode your text first, i.e. using base64
on many POSIX systems the default locale is UTF-8, many Internet protocols often use either UTF-8 or UTF-16
be aware of Mojibake, a garbled text that is the result of using unintended character encoding, i.e. in consoles
a simple rule is: know your input and output encoding, convert characters if necessary
do not forget there is a difference between std::cout and std::wcout

Minimum story explanation:
The very old character set is EBCDIC. It was on its way out when K&R were writing 'The C Programming Language'.
Then there was ASCII where only unaccented English letters matters (32-127).
ASCII come with its room for codes within 128-255.
Codes 128-255 started to be used in various context. IBM-PC provide OEM character set.
ANSI has codified ASCII. 0-127 codes are common and 128-255 varies depending on code page.
In Asia this was not enough. DBCS was introduced (double byte character set). This is the origin of wide characters.
Then Unicode came as a proposition of a character set holding every reasonable writing system.
In Unicode letters maps to so called code points.
The idea is that 'A' in Times New Roman is the same as 'A' in Helvetica, but different from 'a'.
Code points are reffered to with hexadecimal notation of U+0000.
Unicode text can be encoded with either little-endian or big-endian, thus the convention is to store FEFF bytes at the begining of every string (Unicode Byte Order Mark).
Also, there is no real limit on the number of letters that Unicode can define.
Coding redundancy in some languages caused in ignoring Unicode proposition for several years.
Then UTF-8 was invented. It's for storing Unicode code points.
For ANSI ASCII 0-127 codes its 1 B, for 128+ its 2 B, for others its 3, 4, 5 or 6 B.
So, the side effect is that English text looks the same in UTF-8 as it did in ASCII.
The traditional store-it-in-two-bytes methods are called UCS-2 (2 B) or UTF-16 (16 bits).
Not every number is a valid Unicode character. If there's no equivalent code point, you'll get a placeholder sign (a question mark).
The single most important fact about encodings: there is no such thing as plain text. We always need to know input and output encoding or there will be Mojibake.
In HTML, if <meta> is the first tag and charset is different that assumed, the HTML parser should start over with new interpretation of the whole page.

