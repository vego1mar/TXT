*** PREFACE ***
Rvalues indicate object eligible for move operations, while lvalues generally don't.
Rvalues correspond to objects you can refer to, either by name or by following a pointer or lvalue reference.
A useful heuristic to determine whether an expression is an lvalue is to ask if you can take its address. If you can, it typically is.
public: Widget(Widget&& rhs);

Copies of rvalues are generally move constructed, while copies of lvalues are usally copy constructed.
void someFunc(Widget w);
someFunc(std::move(wid))

The arguments are used to initialize the function's parameters.
The distinction between arguments and parameters is important, because parameters are lvalues, but the arguments with which they are initialized may be rvalues or lvalues.
perfect forwarding - an argument passed to a function is passed to a second function such that the original argument's rvalueness or lvalueness is preserved

function object - an object that acts like a function; an object of type supporting an operator() member function
callable objects - anything that can be invoked using the syntax of a non-member function call; this covers operator(), functions, C-like function pointers, member function pointers
closures - function objects created through lambda expressions

Declarations introduce names and types without giving details.
Definitions provide the storage locations or implementation details.
function's signature - a part of its declaration that specifies parameter and return types
undefined behavior - runtime behavior is unpredictable

std::move - treat argument as a temporary object (rvalue); casting rvalue to lvalue is allowed
std::forward - cast a templated function parameter (inside the function) to the value category (lvalue or rvalue); this allows performing a perfect forwarding; casting rvalue to lvalue is prohibited



*** DEDUCING TYPES FOR FUNCTION TEMPLATES ***
template<typename T> void f(ParamType param); f(expr);

(1) ParamType is a pointer or reference type, but not a universal reference - T&
    1. If expr's type is a reference, ignore the reference part.
    2. Then pattern-match expr's type against ParamType to determinate T.
(2) ParamType is a universal reference - T&&
    1. If expr is an lvalue, both T and ParamType are deduced to be lvalue references.
    2. If expr is an rvalue, the 'normal' rules (from above) apply.
(3) ParamType is neither a pointer nor a reference - T
    1. If expr's type is a reference, ignore the reference part.
    2. If, expr is const or volatile ignore that, too.
(4) ParamType is an array or a function argument (arr- and func-to-ptr decay)

Examples:
int x = 27; 
const int cx = x; 
volatile const int& vx = x;
const char* const ptr = "Fun with pointers";
const char name[] = "J. P. Briggs";
void someFunc(int, double);
if ParamType:=T& calling f(cx); then T:=const int and param:=const int &
if ParamType:=T&& calling f(x); then T:=int& and param:=int&
if ParamType:=T&& calling f(27); then T:=int and param:=int&&
if ParamType:=T calling f(vx); then T:=int and param:=int
if ParamType:=T calling f(ptr); then T:=const char* const and param:=const char*
if ParamType:=T calling f(name); then T:=const char* and param:=const char*
if ParamType:=T& calling f(name); then T:=const char[13] and param:=const char(&)[13]
if ParamType:=T& calling f(someFunc); then T:=void (&)(int,double), param:=ref-to-func

constexpr - makes a function declaration result available during compilation
noexcept - help compilers to generate a better code

trailing return type syntax example:
template<typename Container, typename Index>
auto authAndAccess(Container& c, Index i) -> decltype(std:forward<Container>(c)[i]) { 
    authenticateUser(); 
    return c[i]; 
    // C++11
}
template<typename Container, typename Index>
decltype(auto) authAndAccess(Container&& c, Index i) {
    authenticateUser();
    return std::forward<Container>(c)[i];
    // C++14
}


*** AUTO KEYWORD ***
function object - std::function template is a generalization of a function that can point to any callable object (anything that can be invoked as a function); this approach is generally bigger and slower compared with auto approach (closure hold in memory, restricted inlining)

std::vector<int> v;
std::vector<int>::size_type  // official type: unsigned integral type
unsigned sz = v.size();      // on 64-bit Windows: 32 bits
auto sz = v.size();          // on 64-bit Windows: 64 bits

std::unordered_map<std::string, int> m;
for (const std::pair<std::string, int>& p : m) {
    // key is const!
    // type of the pair in the hash table is std::pair<const std::string, int>
    // compiler will do a convertion to std::pair<string, int> for a temporary object
    // explicit type specification leads to implicit convertions
}


std::vector<bool> features(const Widget& w);
Widget w;
bool highPriority = features(w)[5];                    // OK
auto highPriority = features(w)[5];                    // undefined behavior
auto highPriority = static_cast<bool>(features(w)[5]); // explicitly typed initializer idiom
processWidget(w, highPriority);
// std::vector<T> holds operator[] that is supposed to return a T&
// operator[] returns a reference to an element of the container, except bool
// for bools operator[] return std::vector<bool>::reference, a nested class (proxy class)
// std::vector<bool> is specified to represent its bools in packed form, one bit per bool
// yet, C++ forbids references to bits
// not being able to return bool&, operator[] returns an object that acts like a bool&
// to make this work we need an implicit conversion to bool, not to bool&
// auto deduced type depends on the ::reference implementation (i.e. ptr-to-word + offset)
// the call to features returns a temporary std::vector<bool> object temp
// invoked temp->operator[] returns ::reference containing a ptr-to-word plus offset[5]
// highPriority is a copy of a pointer to a word in temp with its offset
// at the end of the statement temp is destroyed because is a temporary object
// this means that highPriority contains a dangling pointer!


proxy class: a class that exists for the purpose of emulating and augmenting the behavior of some other type; std::vector<bool>::reference offers the illusion that operator[] returns a reference to a bit; STL smart pointers types graft resource management onto raw pointers; apparent Proxies examples: std::shared_ptr, std::unique_ptr; invisible Proxies examples: std::vector<bool>::reference, std::bitset::reference, classes from STL using expression templates

// expression template
// originally developed to improve the efficiency of numeric code
Matrix sum = m1 + m2 + m3 + m4;
auto sum = static_cast<Matrix>(m1 + m2 + m3 + m4); 
// explicitly typed initializer idiom
// operator+ for Matrix should return a proxy for the result
// for two Matrix objects the result should be Sum<Matrix, Matrix>
// we need to provide an implicit conversion from the proxy class to Matrix
// the entire initialization expression: Sum<Sum<Sum<Matrix, Matrix>, Matrix>, Matrix>
// general rule: invisible proxy classes don't play well with auto keyword
// proxy classes are often designed to live for a single statement
// creating variables of those types tends to violate fundamental library design assumptions
// how to recognize when proxy objects are in use?
// function signatures usually reflect their existence (they're typically returned from those)
// also, pay careful attention to the interfaces you're using

// explicitly typed initializer idiom
double calcEpsilon();
float ep = calcEpsilon();                    // may be or not deliberate, intend not clear
auto ep = static_cast<float>(calcEpsilon()); // deliberate type reduction


*** DISTINGUISH BETWEEN PARENTHESES AND BRACES ***
uniform initialization: a single initialization syntax that can, at least in concept, be used anywhere and express everything
(1) 'uniform initialization' is an idea, 'braced initialization' is a syntactic construct
(2) specyfing the initial contents of a container is easy
(3) braces can be used to specify default initialization values for non-static data members
(4) it prohibits implicit narrowing conversions among built-in types
(5) it is immune to C++'s most vexing parse
(6) if one or more constructors declare a parameter of type std::initializer_list, calls using the braced iniitialization syntax **strongly** prefer the overloads taking this type

most vexing parse: a side effect of C++'s rule that anything that can be parsed as a declaration must be interpreted as one; usually afflicts situations when you want to default-construct an object, but inadvertently declaring a function instead

Widget w1;                      // call default constructor
Widget w2 = w1;                 // calls copy ctor
w1 = w2;                        // call copy operator=
std::vector<int> v{ 1, 3, 5 };  // initial content is in braces
std::atomic<int> ai1{ 0 };      // assignment, where '=' is not allowed
double x, y, z;
int sum1{ x + y + z };          // ERROR, double not expressible as int
int sum2(x + y + z);            // OK, expression truncated to int
int sum3 = x + y + z;           // ditto
Widget w3(10);                  // call Widget ctor with argument 10
Widget w4();                    // declares a function w2 that returns Widget
Widget w5{};                    // calls Widget ctor with no args

class Widget {
public:
    Widget(int i, bool b);
    Widget(int i, double d);
    Widget(std::initializer_list<long double> il);
    operator float() const;                          // conversion operator
};

Widget w1(10, true);          // first ctor
Widget w3(10, 5.0);           // second ctor
Widget w2{10, true};          // third ctor, conversion to long double
Widget w4{10, 5.0};           // ditto
Widget w5(w4);                // copy ctor
Widget w7(std::move(w4));     // move ctor
Widget w6{w4};                // third ctor, w4 -> float -> long double
Widget w8{std::move(w4)};     // ditto
Widget w9{};                  // edge case, the rule is default construction
Widget w10({});               // third ctor, empty list
std::vector<int> v1(10, 20);  // 10 elements, each of value 20
std::vector<int> v2{10, 20};  // 2 elements, values 10 and 20
                              // is now viewed as an error in the interface design
                              // il overloads overshadows others overloads
                              // in auto type deduction {} is a std:initializer_list

template<typename T, typename... Ts>
void doSomeWork(Ts&&... params) {
    // T - type of objects to create
    // Ts - types of arguments to use
    // we either use parens or braces for parsing
    T localObject(std::forward<Ts>(params)...);
    T localObject{std::forward<Ts>(params)...};
}

std::vector<int> v;
doSomeWork<std::vector<int>>(10, 20);
// for parens, v has 10 elements; for braces, v has 2 elements
// which is correct? only the caller can know!


*** DIFFERENCES BETWEEN 0, NULL, NULLPTR ***
literal 0 is an int, not a pointer
if 0 is used in a context where only a pointer can be used, it'll be interpreted as null pointer, which is a fallback position
the same is true for NULL, yet it is allowed to give it an integral type other than int, especially long
a guideline for C++98 is to avoid overloading on pointer and integral types because of function overload resolution surprises

void f(int);
void f(bool);
void f(void *);
f(0);             // calls f(int)
f(NULL);          // may not compile, otherwise calls f(int)
// if NULL is defined to be 0L than the call is ambiguous
// conversion long -> int, long -> bool, 0L -> void* are equally good

nullptr: a type that can be viewed as a pointer of all types
(1) nullptr does not have integral type nor pointer type
(2) nullptr type is std::nullptr_t
(3) std::nullptr_t is defined to be the type of nullptr
(4) std::nullptr_t implicitly converts to all raw pointer types
(5) overloaded function with nullptr argument always calls the void* overload
(6) preferred to use in templates


*** ALIASES AND TYPEDEFS ***
(1) aliases are possibly easier with function pointers
(2) alias declarations may be templatized (alias templates)

typedef std::unique_ptr<std::unordered_map<std::string, std::string>> UPtrMapSS;
using UPtrMapSS = std::unique_ptr<std::unordered_map<std::string, std::string>>;
typedef void (*FP)(int, const std::string &);
using FP = void (*)(int, const std::string &);


template<typename T>
using MyAllocList = std::list<T, MyAlloc<T>>;
// MyAllocList<Widget> lw;

template<typename T>
struct MyAllocList {
    typedef std::list<T, MyAllocList<T>> type;
};
// MyAllocList<Widget>::type lw;


template<typename T>
class Widget {
private:
    typename MyAllocList<T>::type list;
    // typedef type inside a template must be preceded with typename
    // nested MyAllocList<T>::type is a dependent type
    // ::type may not name a type (there might be a specialization of MyAllocList)
};

template<typename T> using MyAllocList = std::list<T, MyAlloc<T>>;
template<typename T> class Widget {
private:
    MyAllocList<T> list;
    // alias template; typename is neither required nor permitted
    // MyAllocList must name a type, thus MyAllocList<T> is a non-dependent type
};

template<> class MyAllocList<Wine> {
private:
    enum class WineType { White, Red, Rose };
    WineType type;
    // this a MyAllocList template specialization for T=Wine
    // type is a data member, MyAllocList<T>::type inside Widget will refer to it
};


In template metaprogramming (TMP) sometimes there is a need to take template type parameters and create a revised types from them. For example, we want to T=const std::string & turn into std::string. In C++11+ this type of transformations are available as templates and are called type traits. Type traits are implemented as nested typedefs inside templatized structs (reasons for this are historical, Standarization Committee first choose was typedef).
std::remove_const<T>::type               // C++11, const T -> T
std::remove_const_t<T>                   // C++14
std::remove_reference<T>::type           // T&/T&& -> T
std::remove_reference_t<T>
std::add_lvalue_reference<T>::type       // T -> T&
std::add_lvalue_reference_t<T>
std::transformation<T>::type             // C++11 common form
std::transformation_t<T>                 // C++14 alias template


*** SCOPED AND UNSCOPED ENUMS ***
* enum classes reduce namespace pollution by scoping their names (those in braces)
* enum classes are strongly typed (underlying type is int, usually std::size_t), whereas unscoped enums implicitly converts to integral types (usually float or char)
* scoped enums may be forward-declared (no need for enumerators in braces)


enum Color { black, white, red };        // 4 names in the same scope, C++98
auto white = false;                      // ERR, white already declared

enum class Color { black, white, red };  // 3 names scoped to Color, C++11
auto white = false;                      // fine
Color c = white;                         // ERR, white is not declared
auto c = Color::white;                   // fine

auto comparison = c < 14.5;              // OK, for unscoped enum
enum class Status;                       // forward-declaration

enum class Status : std::uint32_t;       // specyfing underlying type
enum Color : std::uint8_t;               // either at declaration or definition


template<typename E>
constexpr auto toUType(E enumerator) noexcept {
    // C++14
    return static_cast<std::underlying_type_t<E>>(enumerator);
}

enum class UserInfoFields { uiName, uiEmail, uiReputation };
using UserInfo = std::tuple<std::string, std::string, std::size_t>;
UserInfo uInfo;
auto val = std::get<toUType(UserInfoFields::uiEmail)>(uInfo);


*** DELETED FUNCTIONS VS PRIVATE FUNCTIONS ***
* making new functions public resulting in better error messages (private complains etc.)
* any function may be deleted, while only member functions may be private
* deleted functions can't be used
* deleted functions are taken into consideration during overload resolution
* deleted functions prevent use of a template instantiations that should be disabled


template<class charT, class traits = char_traits<charT>>
class basic_ios : public ios_base {
public:
    basic_ios(const basic_ios&) = delete;
    basic_ios& operator=(const basic_ios&) = delete;
};


bool isLucky(int number);              // we want only ints
bool isLucky(char) = delete;           // reject chars
bool isLucky(bool) = delete;           // reject bools
bool isLucky(double) = delete;         // reject doubles and floats
                                       // C++ prefers the conversion to double

template<typename T> void processPointer(T* ptr);
template<> void processPointer<void>(void*) = delete;
template<> void processPointer<char>(char*) = delete;
template<> void processPointer<const void>(const void*) = delete;
template<> void processPointer<const char>(const char*) = delete;
template<> void processPointer<const volatile void>(const volatile void*) = delete;
template<> void processPointer<const volatile char>(const volatile char*) = delete;
template<> void processPointer<std::wchar_t>(std::wchar_t*) = delete;
template<> void processPointer<std::char16_t>(std::char16_t*) = delete;
template<> void processPointer<std::char32_t>(std::char32_t*) = delete;
template<> void processPointer<std::char8_t>(std::char8_t*) = delete;
// void*, char* (cv-qualified or not)
// std::wchar_t (depending on compiler and target platform, for wide characters)
// std::char16_t (since C++11, UTF-16, 2 bytes, as std::uint_least16_t)
// std::char32_t (since C++11, UTF-32, 4 bytes, as std::uint_least32_t)
// std::char8_t (since C++20, UTF-8, 1 byte, as unsigned char, char, signed char)


*** OVERRIDED FUNCTIONS ***
Requirements for overriding class member functions:
* base class function must be virtual
* base and derived function names must match (except destructors)
* base and derived function parameter types must match
* base and derived function constness must match
* base and derived function return type and exception specification must be compatible
* base and derived function reference qualifiers must be identical (C++11)

Member function reference qualifiers limits use of a member function to lvalues or rvalues only. They need not be virtual to use them.

class Widget {
public:
    void doWork() &;                 // only when *this is an lvalue
    void doWork() &&;                // only when *this is an rvalue
};

Widget w;
w.doWork();                          // calls Widget::doWork() &
Widget makeWidget();
makeWidget().doWork();               // calls Widget::doWork() &&


Contextual keyword override:
* make explicit that a derived class function is supposed to override a base class version
* compiler will kvetch about all the overriding-related problems

Contextual keyword final:
* (applied to a function) prevents function from being overridden in derived class
* (applied to a class) prohibits from being used as a base class


class Base {
public:
    virtual void mf1() const;
    virtual void mf2(int x);
    virtual void mf3() &;
    virtual void mf4() const;
    void mf5() final;
};

class Derived : public Base {
public:
    virtual void mf1() const override;
    virtual void mf2(int x) override;
    virtual void mf3() & override;
    void mf4() const override;
};



*** UNCONDITIONAL NOEXCEPT SPECIFIER ***
* C++98-style exception remain valid, but they're deprecated (specifying exception types)
* it permits compilers to generate better object code (most optimizable function variant)
** optimizers need not keep the runtime stack in an unwindable state if an exception would propagate out of the function, nor must they ensure that objects in a noexcept function are destroyed in the inverse order of construction should an exception leave the function
** this is true only for noexcept specifier
* swapping higher-level data structures can generally be noexcept only if swapping their lower-level constituents is noexcept
* if an exception tries to leave the function in a noexcept function, the program will be terminated
* most functions are exception-neutral, that is they throw no exceptions themselves, but functions they call might emit one; exception-neutral functions are never noexcept, because they may emit 'just passing through' exceptions
* in C++11 all memory deallocation functions and all destructors, both user-defined and compiler-generated, are implicitly noexcept; the destructor is noexcept only if a data member of the class is of a type which specifies 'noexcept(false)'

int f(int x) throw();       // C++98 style; call stack unwounded + actions + termination
int f(int x) noexcept;      // C++11 style; call stack is possibly unwounded + termination


template<class T, size_t N>
void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));

template<class T1, class T2>
struct pair {
    void swap(pair& p) noexcept(noexcept(swap(first, p.first)), noexcept(swap(second, p.second)));
}
// STL's std::swap for std::pair


functions with wide contracts: never exhibits undefined behaviors, noexcept-friendly
functions with narrow contracts: if a precondition is violated, results are undefined


*** CONSTEXPR OBJECTS AND FUNCTIONS ***
* conceptually, constexpr indicates a value that's not only constant, it's known during compilation
* constexpr proclaims 'I can be used in a context where C++ requires a constant expression'
* by using constexpr whenever possible, you maximize the range of situations in which your objects and functions may be used
* when applied to objects, it's essentially a beefed-up form of const
** constexpr objects values are determined during translation (compilation + linking)
** values known during compilation may be placed in read-only memory (embedded systems)
** constexpr values can be used in contexts where C++ requires an integral constant expression (array sizes, integral template arguments, enumerator values, alignment specifiers, ...)
** all constexpr objects are const, but not all const objects are constexpr
* when applied to functions, things are more nuanced
** the results of constexpr functions may not be const, nor their values are known during compilation
** constexpr functions produce compile-time constants when they are called with compile-time constants
* I/O statements are generally not permitted in constexpr functions
** if any of the arguments' values is not known during compilation, your code will be rejected (in contexts that demand compile-time constants)
** constexpr function called with one or more values that are not known during compilation, it acts like a normal function, computing its result at runtime
** restrictions imposed upon constexpr functions implementation differ between C++11 and C++14
** in C++11, constexpr functions may contain no more than a single executable return statement, yet ternary operator '?:' and recursion are allowed
** in C++11, constexpr member function cannot modify the object, they are implicitly const, they have void return types which isn't a literal type
** in C++14, constexpr functions are limited to taking and returning literal types, which essentially means types that can have values determined during compilation (all built-in types except void, user-defined class with constexpr constructor)


int sz;
const auto arraySize = sz;
std::array<int, arraySize> data;        // ERROR, arraySize not known during compilation
constexpr auto arraySize2 = 10;
std::array<int, arraySize2> data2;      // OK, arraySize2 is constexpr


constexpr int pow(int base, int exp) noexcept {
    return (exp == 0 ? 1 : base * pow(base, exp - 1));
} // C++11

constexpr int pow(int base, int exp) noexcept {
    auto result = 1;
    for (int i=0; i<exp; ++i) result *= base;
    return result;
} // C++14


class Point {
public:
    constexpr Point(double xVal = 0, double yVal = 0) noexcept : x(xVal), y(yVal) {}
    constexpr double xValue() const noexcept { return x; }
    constexpr double yValue() const noexcept { return y }
    constexpr void setX(double newX) noexcept { x = newX; }
    constexpr void setY(double newY) noexcept { y = newY; }
    
private:
    double x, y;
}; // constexpr setters are allowed in C++14

constexpr Point midpoint(const Point& p1, const Point& p2) noexcept {
    return { (p1.xValue() + p2.xValue()) / 2, (p1.yValue() + p2.yValue()) / 2 };
} // non-member function

constexpr Point reflection(const Point& p) noexcept {
    Point result;
    result.setX(-p.xValue());
    result.setY(-p.yValue());
    return result;
}

constexpr Point p1(9.4, 27.7);
constexpr Point p2(28.8, 5.3);
constexpr auto mid = midpoint(p1, p2);          // compile-time constants
constexpr auto reflectedMid = reflection(mid);  // (-19.1, -16.5) known during compilation


*** CONST MEMBER FUNCTIONS ***
* mutable: permits modification of the class member declared mutable even if the containing object is declared const; mutable is used to specify that the member does not affect the external visible state of the class (mutexes, memo caches, lazy evaluation, ...)
* the safe bet is that const member functions will be a subject to concurrent execution, and that's why you should ensure that your const member functions are thread safe
* only data that are mutable & shared requires synchronization; unshared & mutable, unshared & immutable, shared & immutable are not the problem

class Polynomial {
public:
    using RootsType = std::vector<double>;
    RootsType roots() const {
        if (!rootsAreValid) { cacheRoots(); rootsAreValid = true; }
        return rootVals;
    }
private:
    mutable bool rootsAreValid{ false };
    mutable RootsType rootVals{};
};
Polynomial p;
auto rootsOfP = p.roots();                      // thread 1
auto valsGivingZero = p.roots();                // thread 2
// data race: reading and writing the same memory without synchronization
// this code has undefined behavior
// the easiest way to address the issue is to employ a mutex
// mutable std::mutex m; as a field & std::lock_guard<std::mutex> g(m); in roots()
// locking and unlocking are non-const operations, thus mutable keyword (also applying M&M rule)
// std::mutex is a move-only type, thus Polynomial with m loses ability to be copy constructed

class Point {
public:
    double distanceFromOrigin() const noexcept {
        ++callCount;
        return std::sqrt((x * x) + (y * y));
    }
private:
    mutable std::atomic<unsigned> callCount{ 0 };
    double x, y;
};
// counting how many times a member function is called
// std::atomics are often a less expensive way to go than std::mutexes


*** SPECIAL MEMBER FUNCTION GENERATION ***
* in official C++ parlance, the special member functions are the ones that C++ is willing to generate on its own; these functions are generated only if they're needed, i.e., if some code uses them without their being expressly declared in the class
* C++98 has four such functions: the default constructor, the destructor, the copy constructor, the copy assignment operator
* C++11 has six such functions: the default constructor, the destructor, the copy constructor, the copy assignment operator, the move constructor, the move assignment operator
** generated special member functions are implicitly public and inline
** a default constructor is generated only if the class declares no constructor at all
** a destructor is noexcept by default, and is virtual only if a base class destructor is virtual
** a copy constructor is generated only if the class lacks a user-declared copy constructor; deleted if the class declares a move operation; won't be generated in a class with a user-declared copy assignment operator or destructor
** a copy assignment operator is generated only if the class lacks a user-declared copy assignment operator; deleted if the class declares a move operation; won't be generated in a class with a user-declared copy constructor or destructor
** a move constructor and a move assignment operator is generated only if the class contains no user-declared copy operations, move operations, or destructor

* the move operations perform 'memberwise moves' on the non-static data members of the class; they also move-construct its base class parts if they are any; the heart of each 'memberwise' move is application of std::move, that is a member will be moved if it is move-enabled (if it supports move semantics), otherwise it'll be copied
* the move operations are generated when they're needed; the move operations aren't generated if you declare them yourself
* copy operations are independent: copy constructor and copy assignment operator comes together (when both copy operations are treated as defaulted)
* move operations are not independent: if you declare either, that prevents compilers from generating the other; move operations won't be generated for any class that explicitly declares a copy operation
** the rationale is that if you need a custom move constructor, then there's probably something wrong about generated memberwise move assignment operator
** declaring a copy operation declares that the normal approach to memberwise copying an object isn't appropriate for the class; declaring a move operation causes compilers to disable the copy operations by deleting them
** all of this is logical if you think about it, yet this is also about C++98-styled code to behave like in C++98

The Rule of Three states that if you declare any of a copy constructor, copy assignment operator, or destructor, you should declare all three. The justification for this is that almost always copy operation stemmed from the class performing some kind of resource management, which implied that:
* whathever resource management was being done in one copy operation probably needed to be done in the other copy operation
* the class destructor would also be participating in management of the resource, usually releasing it

A consequence of the Rule of Three is that the presence of a user-declared destructor indicates that simple memberwise copy is unlikely to be appropriate for the copying operations in the class. The existence of a user-declared destructor has no impact on compilers' willingness to generate copy operations. That continues to be the case in C++11, but only because restricting the conditions would break too much legacy code (all STL containers declare 'the big three').

So move operations are generated for classes (when needed) only if these three things are true:
* no copy operations are declared in the class
* no move operations are declared in the class
* no destructor is declared in the class

class StringTable {
public:
    StringTable() {}
private:
    std::map<int, std::string> values;
};
// copy & move operations and destructor will automatically be generated if they'll be used
// no user-declared copy operations, thus they'll be implicitly generated
// no explicit copy & move operations and destructor allows for generated move operations

class StringTable {
public:
    StringTable() { makeLogEntry("Creating StringTable object."); }
    ~StringTable() { makeLogEntry("Destroying StringTable object."); }
private:
    std::map<int, std::string> values;
};
// destructor side effect: it prevents the move operations from being generated
// the class is no longer move-enabled, but move requests will compile and run (as copies)

class StringTable {
public:
    StringTable() { makeLogEntry("Creating StringTable object."); }
    ~StringTable() { makeLogEntry("Destroying StringTable object."); };
    StringTable(StringTable&&) = default;
    StringTable(const StringTable&) = default;
    StringTable& operator=(StringTable&&) = default;
    StringTable& operator=(const StringTable&) = default;
};
// no previous problems
// defaulted default constructor: implicitly defined even if other constructors are present

class Widget {
    template<typename T> Widget(const T& rhs);
    template<typename T> Widget& operator=(const T& rhs);
};
// member function template: construct/assign Widget from anything
// compilers will still generate copy and move operations for Widget beside this templates

class Base {
public:
    explicit Base(int) {}
    virtual ~Base() noexcept = default;         // virtual for polymorphic base class
    Base(Base&&) = default;                     // moving
    Base& operator=(Base&&) = default;          // moving at assignment
    Base(const Base&) = default;                // copying
    Base& operator=(const Base&) = default;     // copying at assignment
};
// The Rule of Five
A constructor with a single non-default parameter (until C++11) that is declared without the function specifier explicit is called a converting constructor. It is said that a converting constructor specifies an implicit conversion from the types of its arguments (if any) to the type of its class. Implicitly-declared and user-defined non-explicit copy constructors and move constructors are converting constructors.


*** STD::UNIQUE_PTR ***
* it's the same as std::auto_ptr but with move semantics that is unavailable in C++98
* by default, std::unique_ptr's are the same size as raw pointers (safe assumption)
* std::unique_ptr embodies exclusive ownership semantics
* a non-null std::unique_ptr always owns what it points to
* copying a std::unique_ptr isn't allowed, because it is a move-only type
* the common use cases for std::unique_ptr's are factory functions and Pimpl Idiom implementation
* there is no indexing operator[] for the single-object form std::unique_ptr<T>, while the array form std::unique_ptr<T[]> lacks dereferencing operators (operator* and operator->)
** std::unique_ptr<T[]> make sense when you're using a C-like API that returns a raw pointer to a heap array that you assume ownership of
** std::array, std::vector, std::string are virtually always better data structures choices than raw pointers
* if std::unique_ptr is a data member and object is being destroyed, std::unique_ptr would be also destroyed
** if the ownership chain got interrupted due to an exception or other atypical control flow, the std::unique_ptr owning the managed resource would eventually have its destructor called
** if an exception propagates out of a thread's primary function (for the program's initial thread) or if a noexcept specification is violated, local objects may not be destroyed
** if std::abort or an exit function (std::exit, std::quick_exit, std::_Exit) is called, local objects definitely won't be destroyed
* by default, std::unique_ptr destruction would take place via delete, but, during construction, std::unique_ptr objects can be configured to use custom deleters (arbitrary functions, function objects, function pointers)
** custom deleters may change the size of the smart pointer
*** deleters that are function pointers generally cause the size of a std::unique_ptr to grow from one word to two
*** for function object deleters the change in size is the sizeof() that function object
*** stateless function objects (from lambda expressions with no captures) incur no size penalty
** when a custom deleter is to be used, its type must be specified as the second type argument to std::unique_ptr; deleter type is part of a pointer type
** for custom deleters objects will ultimately be deleted via a base class pointer, thus, for that to work, the base class must have a virtual destructor
* C++11's smart pointers prohibit implicit conversions from a raw to smart pointer
** to assume ownership of the object created via new we are using reset()
** in templates, each use of new should be perfect-forwarded with std::forward for passed arguments to the function template
* std::unique_ptr easily and efficiently converts to a std::shared_ptr

template<typename... Ts> auto makeInvestment(Ts&&... params) {
    auto delInvmt = [](Investment* pInvestment) {
        makeLogEntry(pInvestment);
        delete pInvestment;
    };
    std::unique_ptr<Investment, decltype(delInvmt)> pInv(nullptr, delInvmt);
    if (stock) { pInv.reset(new Stock(std::forward<Ts>(params)...)); }
    else if (bond) { pInv.reset(new Bond(std::forward<Ts>(params)...)); }
    else if (realEstate) { pInv.reset(new RealEstate(std::forward<Ts>(params)...)); }
    return pInv;
} // C++14; Stock & Bond & RealEstate : Investment

template<typename... Ts> 
std::unique_ptr<Investment, void (*)(Investment*)> makeInvestment(Ts&&... params);
// sizeof(Investment) + sizeof(void (*)(Investment*))

std::shared_ptr<Investment> sp = makeInvestment(arguments);
// implicit conversion to std::shared_ptr


*** STD::SHARED_PTR ***
* an object accessed via std::shared_ptr's has its lifetime managed by those pointers through shared ownership
* no specific std::shared_ptr owns the object; instead, all std::shared_ptr's pointing to it collaborate to ensure its destruction at the point where it's no longer needed (when the last std::shared_ptr pointing to an object stops pointing there, that std::shared_ptr destroys the object it points to)
* a std::shared_ptr can tell whether it's the last one pointing to a resource by consulting the resource's reference count, a value associated with the resource that keeps track of how many std::shared_ptr's point to it
** std::shared_ptr constructors increment this count (usually)
** move construction and move assignment is faster than its copy equivalents, because it doesn't require incrementing the reference count
** std::shared_ptr destructors decrement it
** copy assignment operators do both
* the existence of the reference count has its performance implications
** std::shared_ptr's are twice the size of a raw pointer (raw pointer to the resource + raw pointer to the resource's reference count)
** memory for the reference count must be dynamically allocated (pointed to objects have no place to store a reference count); cost of this may be avoided using std::make_shared
** increments and decrements of the reference count must be atomic (to be thread-safe)
* std::shared_ptr uses delete as its default resource-destruction mechanism
* std::shared_ptr supports custom deleters
** deleter type is not part of pointer type
** specifying a custom deleter doesn't change the size of a std::shared_ptr object
** regardless of deleter, a std::shared_ptr object is two pointers in size
** custom deleters cannot be combined with std::make_shared
* the reference count is part of a larger data structure known as the control block
** there's a control block for each object managed by std::shared_ptr's
** control block may contains the reference count, a weak count (a secondary reference count), other data (custom deleters, custom allocators, ...)
** thus, reinvisioned, std::shared_ptr<T> contains PtrToT and PtrToControlBlock
** we assume that an object's control block is set up by the function creating the first std::shared_ptr to the object; in practice, we use rules for control block creation
*** std::make_shared always create a control block
*** a control block is created when a std::shared_ptr is constructed from a unique-ownership pointer
*** when a std::shared_ptr constructor is called with a raw pointer, it creates a control block
** the usual control block implementation makes use of inheritance and virtual function to ensure that the pointed-to object is properly destroyed
* having dynamically allocated control block, arbitrarily large deleters and allocators, virtual function machinery, and atomic reference count manupulations, std::shared_ptr exact a very reasonable cost
** the control block is only about three words in size, in typical conditions (defaulted)
** its allocation is essentially free (it's incorporated into the memory allocation for the object being pointed to)
** dereferencing is no more expensive than dereferencing a raw pointer
** atomic operations entails to one-two individual machine instructions
** the virtual function machinery in the control block is generally used only once per object at destruction time
* std::shared_ptr's are designed only for pointers to single objects, there's no std::shared_ptr<T[]>
** you still can point to an array with array-to-pointer decay and specify a custom deleter with delete[], yet std::shared_ptr offers no operator[], so indexing requires expressions based on pointer arithmetic
** declaring a smart pointer to a dumb array is almost always a sign of a bad design (use std::vector instead)

sp1 = sp2;
// the reference count for sp1 is decremented, for sp2 is incremented

auto loggingDel = [](Widget *pw) {
    makeLogEntry(pw);
    delete pw;
};
std::unique_ptr<Widget, decltype(loggingDel)> upw(new Widget, loggingDel);
std::shared_ptr<Widget> spw(new Widget, loggingDel);

auto pw = new Widget;                           // raw pointer
std::shared_ptr<Widget> spw1(pw, loggingDel);   // create control block for *pw
std::shared_ptr<Widget> spw2(pw, loggingDel);   // create control block for *pw
                                                // undefined behavior
std::shared_ptr<Widget> spw2(spw1);             // same control block as spw1

std::vector<std::shared_ptr<Widget>> processedWidgets;
void Widget::process() {
    processedWidgets.emplace_back(this);
    // it's passing a raw pointer to a container of std::shared_ptr's
    // thus they will create a new control block for the pointed-to Widget of *this
    // if there are std::shared_ptr's outside the member function that already point to that Widget,
    // it's match for undefined behavior
}

class Widget : public std::enable_shared_from_this<Widget> { ... };
// if you want to be able to safely create a std::shared_ptr from a this pointer
// The Curiously Recurring Template Pattern (CRTP)
// a derived class inherits from a base class by templatizing on a derived class
void Widget::process() {
    processedWidgets.emplace_back(shared_from_this());
    // add std::shared_ptr to current object to processedWidgets
    // std::enable_shared_from_this::shared_from_this is a member function
    // internally, it looks up the control block for the current object, and creates a referee
    // the design relies on the current object having an associated control block
    // so, there must an existing std::shared_ptr that points to the current object
    // if no such std::shared_ptr exists, behavior is undefined (but may throw an exception)
}


*** STD::WEAK_PTR ***
* std::weak_ptr tracks when it dangles, that is when the object it is supposed to point to no longer exists
** std::weak_ptr's can detect when they dangle only when an object's lifetime is managed by std::shared_ptr's
* std::weak_ptr's are typically created from std::shared_ptr's, but they don't affect the reference count of the object they point to
* std::weak_ptr is an augmentation of std::shared_ptr
** std::weak_ptr can't be dereferenced
** std::weak_ptr can't be testes for nullness
* accessing std::weak_ptr may be done by creating a std::shared_ptr from the std::weak_ptr
* std::weak_ptr's objects are the same size as std::shared_ptr's, they make use of the same control blocks
* std::weak_ptr's don't participate in the shared ownership of objects
** there's a second reference count in the control block, and it's manipulated by them (weak count)
* as long as std::weak_ptr refer to a control block, that control block must continue to exist

* as a use case for std::weak_ptr consider factory function that loads and caches expensive objects
** a second use case: Observer design pattern
** in most implementations, each subject contains a data member holding pointers to its observers
** subjects have no interest in controlling the lifetime of their observers
** subjects have a great interest in making sure that if an observer gets destroyed, subjects don't try to subsequently access it

** a third use case: A --(std::shared_ptr)--> B <--(std::shared_ptr)-- C
** we want to have a pointer from B back to A
** there are three choices: a raw pointer, a std::shared_ptr, a std::weak_ptr
** a raw pointer won't be able to detect a dangling pointer
** a std::shared_ptr will provide a reference count of one for both A and B
** a std::weak_ptr will be able to detect dangling pointer and will not interfere with the reference count


auto spw = std::make_shared<Widget>();
std::weak_ptr<Widget> wpw(spw);
spw = nullptr;
if (wpw.expired()) {
    // std::weak_ptr's that dangle are said to have expired
    // note, that separating the check and the dereferencing action would introduce a race condition
    // another thread might be involved, thus causing an undefined behavior
}

auto spw2 = wpw.lock();                         // null if wpw expired
std::shared_ptr<Widget> spw3(wpw);              // if wpw expired throws std::bad_weak_ptr

std::shared_ptr<const Widget> fastLoadWidget(WidgetID id) {
    static std::unordered_map<WidgetID, std::weak_ptr<const Widget>> cache;
    auto objPtr = cache[id].lock();
    if (!objPtr) {
        objPtr = loadWidget(id);
        cache[id] = objPtr;
    }
    return objPtr;
}
// a factory function that produces smart pointers to read-only objects based on a unique ID
// it's common for IDs to be used repeatedly, loadWidget() is an expensive call
// reasonable optimization is caching and destroying Widgets when they're no longer in use


*** STD::MAKE_UNIQUE & STD::MAKE_SHARED ***
* std::make_shared is part of C++11, std::make_unique is part of C++14
* STL make functions are: std::make_shared, std::make_unique, std::allocate_shared
** make function take an arbitrary set of arguments, perfect-forwards them to the constructor for a dynamically allocated object, and return a smart pointer to that object
** std::allocate_shared acts like std::make_shared, yet its first argument is an allocator object
* there are two reasons to prefer make functions
** make function don't repeat type being created, new does
** it provides exception safety
** for std::unique_ptr custom deleters and braced initializers are scenerios where make functions are problematic
** for std::shared_ptr problematic are custom deleters, braced initializers, custom operator new, custom operator delete
* std::make_shared improves code efficiency; this also applicable to std::allocate_shared
* make functions do not permit of custom deleters
* if the object type is quite large and the time between destruction of the last std::shared_ptr and the last std::weak_ptr is significant, a lag can occur between when an object is destroyed and when the memory it occupied is freed


auto upw1(std::make_unique<Widget>());
std::unique_ptr<Widget> upw2(new Widget);

void processWidget(std::shared_ptr<Widget> spw, int priority);
int computePriority();
processWidget(std::shared_ptr<Widget>(new Widget), computePriority());
// potential resource leak
// compilers may emit code in order: new Widget, computePriority(), std::shared_ptr constructor
processWidget(std::make_shared<Widget>(), computePriority());
// if exception will be thrown, std::shared_ptr destructor will be invoked

std::shared_ptr<Widget> spw(new Widget);        // 2 allocations: Widget + control block
auto spw = std::make_shared<Widget>();          // 1 allocation: ditto but in single chunk

auto widgetDeleter = [](Widget* pw) {};
std::unique_ptr<Widget, decltype(widgetDeleter)> upw(new Widget, widgetDeleter);
std::shared_ptr<Widget> spw(new Widget, widgetDeleter);
// cannot be done using make functions

auto initList = { 10, 20 };
auto spv = std::make_shared<std::vector<int>>(initList);
// initList is a std::initializer_list object
// std::vector's perfect-forward code using parentheses, not braces
// if you want to construct pointed-to object using a braced initializers, you must use new directly
// braced initializers can't be perfect-forwarded
// using auto type deduction to create a std::initializer_list object is a workaround

class ReallyBigType {};
auto pBigObj = std::make_shared<ReallyBigType>();
// 1. Creating and working with std::shared_ptr's and std::weak_ptr's.
// 2. Last std::shared_ptr is being destroyed, but std::weak_ptr's remain.
// 3. Memory formerly occupied by large object remains allocated.
// 4. Last std::weak_ptr is being destroyed, memory for control block and object is released.
std::shared_ptr<ReallyBigType> pBigObj(new ReallyBigType);
// 1. As before.
// 2. As before, plus memory object is deallocated.
// 3. Only memory for the control block remains allocated.
// 4. Last std::weak_ptr is being destroyed, memory for control block is released.

void processWidget(std::shared_ptr<Widget> spw, int priority);
void cusDel(Widget *ptr);
processWidget(std::shared_ptr<Widget>(new Widget, cusDel), computePriority());
// exception-unsafe call; we're passing an rvalues to processWidget()
std::shared_ptr<Widget> spw(new Widget, cusDel);
processWidget(spw, computePriority());
// when you use new directly, immediately pass the result to a smart pointer constructor...
// in a statement that does nothing else (compiler code emitting technique)
// if spw's constructor throws an exception, it's guaranteed that cusDel will be invoked
// we're passing an lvalue to processWidget()
processWidget(std::move(spw), computePriority());
// optimization; moving std::shared_ptr requires no reference count manipulation


*** PIMPL IDIOM ***
Pimpl Idiom: a 'pointer to implementation' idiom; that's the technique whereby you replace the data members of a class with a pointer to an implementation class; used to combat excessive build times

class Widget {                    // in header "widget.h"
public:
    Widget();
private:
    std::string name;             // in header <string>
    std::vector<double> data;     // in header <vector>
    Gadget g1, g2, g3;            // in header "gadget.h"
};
// if a header's content changes, Widget clients must recompile

class Widget {                    // in header "widget.h"
public:
    Widget();
    ~Widget();                    // needed
private:
    struct Impl;                  // just declared type (incomplete type)
    Impl *pImpl;
};
// if something changes in headers, Widget clients are unaffected

#include "widget.h"                   // "widget.cpp"
#include "gadget.h"
#include <string>
#include <vector>
struct Widget::Impl {                 // define data members
    std::string name;
    std::vector<double> data;
    Gadget g1, g2, g3;
};
Widget::Widget() : pImpl(new Impl) {  // allocate data members
}
Widget::~Widget() {
    delete pImpl;                     // destroy data members
}
// C++98 style


class Widget {                        // "widget.h"
public:
    Widget();
private:
    struct Impl;
    std::unique_ptr<Impl> pImpl;
};
struct Widget::Impl {                 // "widget.cpp"
    std::string name;
    std::vector<double> data;
    Gadget g1, g2, g3;
};
Widget::Widget() : pImpl(std::make_unique<Impl>()) {
}
// C++11 style

#include "widget.h"
Widget w;            // ERROR, applying sizeof/delete to an incomplete type!
                     // default deleter uses delete on a raw pointer
                     // default deleter employ static_assert to an incomplete type
                     // the type becomes complete when its definition has been seen
                     
                     
class Widget {                             // "widget.h"
public:
    Widget();
    ~Widget();                             // declaration only
    Widget(Widget&& rhs);                  // declaration only
    Widget& operator=(Widget&& rhs);       // declaration only
    Widget(const Widget& rhs);             // declaration only
    Widget& operator=(const Widget& rhs);  // declaration only
private:
    struct Impl;
    std::unique_ptr<Impl> pImpl;
};
struct Widget::Impl {                      // "widget.cpp"
    std::string name;
    std::vector<double> data;
    Gadget g1, g2, g3;
};
Widget::Widget() : pImpl(std::make_unique<Impl>()) {
}
Widget::~Widget() = default;
Widget::Widget(Widget&& rhs) = default;
Widget& Widget::operator=(Widget&& rhs) = default;
Widget::Widget(const Widget& rhs) : pImpl(std::make_unique<Impl>(*rhs.pIml)) {}
Widget& Widget::operator=(const Widget& rhs) {
    *pImpl = *rhs.pImpl;
    return *this;
}
// applying move and copy support
// move assignment operator needs to destroy the Impl object before reassigning it
// consider w1 = w2; for already existing  Widget's w1 and w2
// in terms of a move ctor, if an exception arises inside the ctor, dtor will invoke
// copy operations calls compiler-generated Widget::Impl's copy operations


class Widget {                     // "widget.h"
public:
    Widget();                      // plus compiler-generated special functions
private:
    struct Impl;
    std::shared_ptr<Impl> pImpl;
};

Widget w1;
auto w2(std::move(w1));
w1 = std::move(w2);
// for std::shared_ptr, the type of the deleter is not part of the type of the smart pointer
// thus, pointed-to types need not be complete when compiler-generated special functions are employed



*** STD::MOVE & STD::FORWARD ***
* std::move doesn't move anything, std::forward doesn't forward anything
* at runtime, neither does anything at all; they generate no executable code
* they both are function templates that perform casts
* std::move unconditionally casts its argument to an rvalue, while std::forward performs this cast only if a particular condition is fulfilled

template<typename T> decltype(auto) move(T&& param) {
    using ReturnType = remove_reference_t<T>&&;
    return static_cast<ReturnType>(param);
} // C++14, approximation of std::move implementation


* rvalues are only usually candidates for moving
** move requests on const objects are silently transformed into copy operations
** std::move doesn't guarantee that the object it's casting will be eligible to be moved

class Annotation {
public:
    explicit Annotation(const std::string text) : value(std::move(text)) {
        // value is copied
    }
private:
    std::string value;
};
class string {
public:
    string(const string& rhs);
    string(string&& rhs);
};
// std::string is a typedef for std::basic_string<char>
// the copy constructor is invoked


* std::move is a conditional cast
** the most common scenerio is a function template taking a universal reference parameter that is to be passed to another function

void process(const Widget& lvalArg);
void process(Widget&& rvalArg);
template<typename T> void logAndProcess(T&& param) {
    auto now = std::chrono::system_clock::now();
    makeLogEntry("Calling 'process'", now);
    process(std::forward<T>(param));
}
// (formal) parameter is always an lvalue
// (actual) argument is either an lvalue or an rvalue
// std::forward recognizes lvalue- and rvalueness based on parameter T


* both std::move and std::forward boil down to casts
** std::move always casts, while std::forward only sometimes does
** argument passing to std::forward should be a non-reference to designate rvalue

class Widget {
public:
    Widget(Widget&& rhs) : s(std::move(rhs.s)) {
        // std::move approach
        ++moveCtorCalls;
    }
private:
    static std::size_t moveCtorCalls;
    std::string s;
};

class Widget {
public:
    Widget(Widget&& rhs) : s(std::forward<std::string>(rhs.s)) {
        // std::forward approach
        ++moveCtorCalls;
    }
private:
    static std::size_t moveCtorCalls;
    std::string s;

};


*** UNIVERSAL REFERENCES & RVALUE REFERENCES ***
* universal references (forwarding references) differs from rvalue references
** rvalue reference T&& binds only to rvalues, and its primary reason is to identify objects that may be moved from
** forwarding reference T&& is either rvalue reference or lvalue reference
*** they can bind to virtually anything
*** they are references that must be initialized
*** universal references arise in two contexts: function template parameters, auto declarations
*** both contexts have in common the presence of type deduction

void f(Widget&& param);                               // rvalue reference
Widget&& var1 = Widget();                             // rvalue reference
auto&& var2 = var1;                                   // forwarding reference
template<typename T> void f(std::vector<T>&& param);  // rvalue reference
template<typename T> void f(T&& param);               // forwarding reference


* for a reference to be universal, type deduction is necessary, but it's not sufficient
** the form of the reference declaration must also be correct
** it must be precisely T&&
** the simple presence of a const qualifier is enough to disqualify a reference from being universal
** auto&& is a correct form of T&&

template<typename T> void f(T&& param);               // universal reference
template<typename T> void f(const T&& param);         // rvalue reference
Widget w;
f(w);                                                 // param=Widget& (lvalue)
f(std::move(w));                                      // param=Widget&& (rvalue)

auto timeFuncInvocation = [](auto&& func, auto&&... params) {
    const clock_t begin_time = clock();
    std::forward<decltype(func)>(func)(std::forward<decltype(params)>(params...));
    return float(clock() - begin_time) / CLOCKS_PER_SEC;
};


* if you see a function parameter of type T&&, you **can't** assume that it's universal reference
* the corner case is where the caller explicitly specifies the type

template<class T, class Allocator = allocator<T>>
class vector {
public:
    void push_back(T&& x);
    template<class... Args> void emplace_back(Args&&... args);
    // forwarding references
};

class vector<Widget, allocator<Widget>> {
public:
    void push_back(Widget&& x);
    template<Ts...> void emplace_back(Ts&&... args);
    // push_back: rvalue reference
    // emplace_back: Args must be deduced with each function call
};


* all of this is a technical lie (abstraction)
* the underlying truth is known as reference collapsing




*** ITEMS ***
** Deducing types
Item 01: Understand template type deduction.
Item 02: Understand auto type deduction.
Item 03: Understand decltype.
Item 04: Know how to view deduced types.

** auto
Item 05: Prefer auto to explicit type declarations.
Item 06: Use the explicitly typed initializer idiom when auto deduces undesired types.

** Moving to modern C++
Item 07: Distinguish between () and {} when creating objects.
Item 08: Prefer nullptr to 0 and NULL.
Item 09: Prefer alias declarations to typedefs.
Item 10: Prefer scoped enums to unscoped enums.
Item 11: Prefer deleted functions to private undefined ones.
Item 12: Declare overriding functions override.
Item 13: Prefer const_iterators to iterators.
Item 14: Declare functions noexcept if they won't emit exceptions.
Item 15: Use constexpr whenever possible.
Item 16: Make const member functions thread safe.
Item 17: Understand special member function generation.

** Smart pointers
Item 18: Use std::unique_ptr for exclusive-ownership resource management.
Item 19: Use std::shared_ptr for shared-ownership resource management.
Item 20: Use std::weak_ptr for std::shared_ptr-like pointers that can dangle.
Item 21: Prefer std::make_unique and std::make_shared to direct use of new.
Item 22: When using the Pimpl Idiom, define special member functions in the implementation file.

** Rvalue references, move semantics, and perfect forwarding
Item 23: Understand std::move and std::forward.
Item 24: Distinguish universal references from rvalue references.




*** THINGS TO REMEMBER ***
** Item 1
* During template type deduction, arguments that are references are treated as non-references, i.e., their reference-ness is ignored.
* When deducing types for universal reference parameters, lvalue arguments get special treatment.
* When deducing types for by-value parameters, const and/or volatile arguments are treated as non-const and non-volatile.
* During template type deduction, arguments that are array or function names decay to pointers, unless they're used to initialize references.

** Item 2
* auto type deduction is usually the same as template type deduction, but auto type deduction assumes that a braced initializer represents a std:initializer_list, and template type deduction doesn't.
* auto in a function return type or a lambda parameter implies template type deduction, not auto type deduction.

** Item 3
* decltype almost always yields the type of a variable or expression without any modifications.
* For lvalue expressions of type T other than names, decltype always reports a type of T&.
* C++14 supports decltype(auto), which, like auto, deduces a type from its initializer, but it performs the type deduction using the decltype rules.

** Item 4
* Deduced types can often be seen using IDE editors, compiler error messages, and the Boost TypeIndex library.
* The results of some tools may be neither helpful nor accurate, so an understanding of C++'s type deduction rules remains essential.

** Item 5
* auto variables must be initialized, are generally immune to type mismatches that can lead to portability or efficiency problems, can ease the process of refactoring, and typically require less typing than variables with explicitly specified types.

** Item 6
* 'Invisible' proxy types can cause auto to deduce the 'wrong' type for an initializing expression.
* The explicitly typed initializer idiom forces auto to deduce the type you want it to have.

** Item 7
* Braced initialization is the most widely usable initialization syntax, it prevents narrowing conversions, and it's immune to C++'s most vexing parse.
* During constructor overload resolution, braced initializers are matched to std::initializer_list parameters if at all possible, even if other constructors offer seemingly better matches.
* An example of where the choice between parentheses and braces can make a significant difference is creating a std::vector<numeric_type> with two arguments.
* Choosing between parentheses and braces for object creation inside templates can be challenging.

** Item 8
* Prefer nullptr to 0 and NULL.
* Avoid overloading on integral and pointer types.

** Item 9
* typedef's don't support templatization, but alias declarations do.
* Alias templates avoid the '::type' suffix, and, in templates, the 'typename' prefix often required to refer to typedefs.
* C++14 offers alias templates for all the C++11 type traits transformations.

** Item 10
* C++98-style enums are now known as unscoped enums.
* Enumerators of scoped enums are visible only within the enum. They convert to other types only with a cast.
* Both scoped and unscoped enums support specification of the underlying type. The default underlying type for scoped enums is int. Unscoped enums have no default underlying type.
* Scoped enums may always be forward-declared. Unscoped enums may be forward-declared only if their declaration specifies an underlying type.

** Item 11
* Prefer deleted functions to private undefined ones.
* Any function may be deleted, including non-member functions and template instantiations.

** Item 12
* Declare overriding functions override.
* Member function reference qualifiers make it possible to treat lvalue and rvalue objects (*this) differently.

** Item 13
* Prefer const_iterators to iterators.
* In maximally generic code, prefer non-member versions of begin, end, rbegin, etc., over their member function counterparts.

** Item 14
* noexcept is part of function's interface, and that means that callers may depend on it.
* noexcept functions are more optimizable than non-noexcept functions.
* noexcept is particularly valuable for the move operations, swap, memory deallocation functions, and destructors.
* Most functions are exception-neutral rather than noexcept.

** Item 15
* constexpr objects are const and are initialized with values known during compilation.
* constexpr functions can produce compile-time results when called with arguments whose values are known during compilation.
* constexpr objects and functions may be used in a wider range of contexts than non-constexpr objects and functions.
* constexpr is part of an object's or function's interface.

** Item 16
* Make const member functions thread safe unless you're certain they'll never be used in a concurrent context.
* Use of std::atomic variables may offer better performance than a mutex, but they're suited for manipulation of only a single variable or memory location.

** Item 17
* The special member functions are those compilers may generate on their own: default constructor, destructor, copy operations, and move operations.
* Move operations are generated only for classes lacking explicitly declared move operations, copy operations, and a destructor.
* The copy constructor is generated only for classes lacking an explicitly declared copy constructor, and it's deleted if a move operation is declared. The copy assignment operator is generated only for classes lacking an explicitly declared copy assignment operator, and it's deleted if a move operation is declared. Generation of the copy operations in classes with an explicitly declared destructor is deprecated.
* Member function templates never suppress generation of special member functions.

** Item 18
* std::unique_ptr is a small, fast, move-only smart pointer for managing resources with exclusive-ownership semantics.
* By default, resource destruction takes place via delete, but custom deleters can be specified. Stateful deleters and function pointers as deleters increase the size of std::unique_ptr objects.
* Converting a std::unique_ptr to a std::shared_ptr is easy.

** Item 19
* std::shared_ptr's offer convenience approaching that of garbage collection for the shared lifetime management of arbitrary resources.
* Compared to std::unique_ptr, std::shared_ptr objects are typically twice as big, incur overhead for control blocks, and require atomic reference count manipulations.
* Default resource destruction is via delete, but custom deleters are supported. The type of the deleter has no effect on the type of the std::shared_ptr.
* Avoid creating std::shared_ptr's from variables of raw pointer type.

** Item 20
* Use std::weak_ptr for std::shared_ptr-like pointers that can dangle.
* Potential use cases for std::weak_ptr include caching, observer lists, and the prevention of std::shared_ptr cycles.

** Item 21
* Compared to direct use of new, make functions eliminate source code duplication, improve exception safety, and, for std::make_shared and std::allocate_shared, generate code that's smaller and faster.
* Situations where use of make functions is inappropriate include the need to specify custom deleters and a desire to pass braced initializers.
* For std::shared_ptr's, additional situations where make functions may be ill-advised include (1) classes with custom memory management and (2) systems with memory concerns, very large objects, and std::weak_ptr's that outlive the corresponding std::shared_ptr's.

** Item 22
* The Pimpl Idiom decreases build times by reducing compilation dependencies between class clients and class implementations.
* For std::unique_ptr pImpl pointers, declare special member functions in the class header, but implement them in the implementation file. Do this even if the default function implementations are acceptable.
* The above advice applies to std::unique_ptr, but not to std::shared_ptr.

** Item 23
* std::move performs an unconditional cast to an rvalue. In and of itself, it doesn't move anything.
* std::forward casts its argument to an rvalue only if that argument is bound to an rvalue.
* Neither std::move nor std::forward do anything at runtime.


** Item 24
* If a function template parameter has type T&& for a deduced type T, or if an object is declared using auto&&, the parameter or object is a universal reference.
* If the form of the type declaration isn't precisely type&&, or if type deduction does not occur, type&& denotes an rvalue reference.
* Universal references correspond to rvalue references if they're initialized with rvalues. They correspond to lvalue references if they're initialized with lvalues.


