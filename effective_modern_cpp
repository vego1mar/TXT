*** PREFACE ***
Rvalues indicate object eligible for move operations, while lvalues generally don't.
Rvalues correspond to objects you can refer to, either by name or by following a pointer or lvalue reference.
A useful heuristic to determine whether an expression is an lvalue is to ask if you can take its address. If you can, it typically is.
public: Widget(Widget&& rhs);

Copies of rvalues are generally move constructed, while copies of lvalues are usally copy constructed.
void someFunc(Widget w);
someFunc(std::move(wid))

The arguments are used to initialize the function's parameters.
The distinction between arguments and parameters is important, because parameters are lvalues, but the arguments with which they are initialized may be rvalues or lvalues.
perfect forwarding - an argument passed to a function is passed to a second function such that the original argument's rvalueness or lvalueness is preserved

function object - an object that acts like a function; an object of type supporting an operator() member function
callable objects - anything that can be invoked using the syntax of a non-member function call; this covers operator(), functions, C-like function pointers, member function pointers
closures - function objects created through lambda expressions

Declarations introduce names and types without giving details.
Definitions provide the storage locations or implementation details.
function's signature - a part of its declaration that specifies parameter and return types
undefined behavior - runtime behavior is unpredictable

std::move - treat argument as a temporary object (rvalue); casting rvalue to lvalue is allowed
std::forward - cast a templated function parameter (inside the function) to the value category (lvalue or rvalue); this allows performing a perfect forwarding; casting rvalue to lvalue is prohibited



*** DEDUCING TYPES FOR FUNCTION TEMPLATES ***
template<typename T> void f(ParamType param); f(expr);

(1) ParamType is a pointer or reference type, but not a universal reference - T&
    1. If expr's type is a reference, ignore the reference part.
    2. Then pattern-match expr's type against ParamType to determinate T.
(2) ParamType is a universal reference - T&&
    1. If expr is an lvalue, both T and ParamType are deduced to be lvalue references.
    2. If expr is an rvalue, the 'normal' rules (from above) apply.
(3) ParamType is neither a pointer nor a reference - T
    1. If expr's type is a reference, ignore the reference part.
    2. If, expr is const or volatile ignore that, too.
(4) ParamType is an array or a function argument (arr- and func-to-ptr decay)

Examples:
int x = 27; 
const int cx = x; 
volatile const int& vx = x;
const char* const ptr = "Fun with pointers";
const char name[] = "J. P. Briggs";
void someFunc(int, double);
if ParamType:=T& calling f(cx); then T:=const int and param:=const int &
if ParamType:=T&& calling f(x); then T:=int& and param:=int&
if ParamType:=T&& calling f(27); then T:=int and param:=int&&
if ParamType:=T calling f(vx); then T:=int and param:=int
if ParamType:=T calling f(ptr); then T:=const char* const and param:=const char*
if ParamType:=T calling f(name); then T:=const char* and param:=const char*
if ParamType:=T& calling f(name); then T:=const char[13] and param:=const char(&)[13]
if ParamType:=T& calling f(someFunc); then T:=void (&)(int,double), param:=ref-to-func

constexpr - makes a function declaration result available during compilation
noexcept - help compilers to generate a better code

trailing return type syntax example:
template<typename Container, typename Index>
auto authAndAccess(Container& c, Index i) -> decltype(std:forward<Container>(c)[i]) { 
    authenticateUser(); 
    return c[i]; 
    // C++11
}
template<typename Container, typename Index>
decltype(auto) authAndAccess(Container&& c, Index i) {
    authenticateUser();
    return std::forward<Container>(c)[i];
    // C++14
}


*** AUTO KEYWORD ***
function object - std::function template is a generalization of a function that can point to any callable object (anything that can be invoked as a function); this approach is generally bigger and slower compared with auto approach (closure hold in memory, restricted inlining)

std::vector<int> v;
std::vector<int>::size_type  // official type: unsigned integral type
unsigned sz = v.size();      // on 64-bit Windows: 32 bits
auto sz = v.size();          // on 64-bit Windows: 64 bits

std::unordered_map<std::string, int> m;
for (const std::pair<std::string, int>& p : m) {
    // key is const!
    // type of the pair in the hash table is std::pair<const std::string, int>
    // compiler will do a convertion to std::pairt<string, int> for a temporary object
    // explicit type specification leads to implicit convertions
}


std::vector<bool> features(const Widget& w);
Widget w;
bool highPriority = features(w)[5];                    // OK
auto highPriority = features(w)[5];                    // undefined behavior
auto highPriority = static_cast<bool>(features(w)[5]); // explicitly typed initializer idiom
processWidget(w, highPriority);
// std::vector<T> holds operator[] that is supposed to return a T&
// operator[] returns a reference to an element of the container, except bool
// for bools operator[] return std::vector<bool>::reference, a nested class (proxy class)
// std::vector<bool> is specified to represent its bools in packed form, one bit per bool
// yet, C++ forbids references to bits
// not being able to return bool&, operator[] returns an object that acts like a bool&
// to make this work we need an implicit conversion to bool, not to bool&
// auto deduced type depends on the ::reference implementation (i.e. ptr-to-word + offset)
// the call to features returns a temporary std::vector<bool> object temp
// invoked temp->operator[] returns ::reference containing a ptr-to-word plus offset[5]
// highPriority of a copy of a pointer to a word in temp with its offset
// at the end of the statement temp is destroyed because is a temporary object
// this means that highPriority contains a dangling pointer!


proxy class: a class that exists for the purpose of emulating and augmenting the behavior of some other type; std::vector<bool>::reference offers the illusion that operator[] returns a reference to a bit; STL smart pointers types graft resource management onto raw pointers; apparent Proxies examples: std::shared_ptr, std::unique_ptr; invisible Proxies examples: std::vector<bool>::reference, std::bitset::reference, classes from STL using expression templates

// expression template
// originally developed to improve the efficiency of numeric code
Matrix sum = m1 + m2 + m3 + m4;
auto sum = static_cast<Matrix>(m1 + m2 + m3 + m4); 
// explicitly typed initializer idiom
// operator+ for Matrix should return a proxy for the result
// for two Matrix objects the result should be Sum<Matrix, Matrix>
// we need to provide an implicit conversion from the proxy class to Matrix
// the entire initialization expression: Sum<Sum<Sum<Matrix, Matrix>, Matrix>, Matrix>
// general rule: invisible proxy classes don't play well with auto keyword
// proxy classes are often designed to live for a single statement
// creating variables of those types tends to violate fundamental library design assumptions
// how to recognize when proxy objects are in use?
// function signatures usually reflect their existence (they're typically returned from those)
// also, pay careful attention to the interfaces you're using

// explicitly typed initializer idiom
double calcEpsilon();
float ep = calcEpsilon();                    // may be or not deliberate, intend not clear
auto ep = static_cast<float>(calcEpsilon()); // deliberate type reduction


*** DISTINGUISH BETWEEN PARENTHESES AND BRACES ***
uniform initialization: a single initialization syntax that can, at least in concept, be used anywhere and express everything
(1) 'uniform initialization' is an idea, 'braced initialization' is a syntactic construct
(2) specyfing the initial contents of a container is easy
(3) braces can be used to specify default initialization values for non-static data members
(4) it prohibits implicit narrowing conversions among built-in types
(5) it is immune to C++'s most vexing parse
(6) if one or more constructors declare a parameter of type std::initializer_list, calls using the braced iniitialization syntax **strongly** prefer the overloads taking this type

most vexing parse: a side effect of C++'s rule that anything that can be parsed as a declaration must be interpreted as one; usually afflicts situations when you want to default-construct an object, but inadvertently declaring a function instead

Widget w1;                      // call default constructor
Widget w2 = w1;                 // calls copy ctor
w1 = w2;                        // call copy operator=
std::vector<int> v{ 1, 3, 5 };  // initial content is in braces
std::atomic<int> ai1{ 0 };      // assignment, where '=' is not allowed
double x, y, z;
int sum1{ x + y + z };          // ERROR, double not expressible as int
int sum2(x + y + z);            // OK, expression truncated to int
int sum3 = x + y + z;           // ditto
Widget w3(10);                  // call Widget ctor with argument 10
Widget w4();                    // declares a function w2 that returns Widget
Widget w5{};                    // calls Widget ctor with no args

class Widget {
public:
    Widget(int i, bool b);
    Widget(int i, double d);
    Widget(std::initializer_list<long double> il);
    operator float() const;                          // conversion operator
};

Widget w1(10, true);          // first ctor
Widget w3(10, 5.0);           // second ctor
Widget w2{10, true};          // third ctor, conversion to long double
Widget w4{10, 5.0};           // ditto
Widget w5(w4);                // copy ctor
Widget w7(std::move(w4));     // move ctor
Widget w6{w4};                // third ctor, w4 -> float -> long double
Widget w8{std::move(w4)};     // ditto
Widget w9{};                  // edge case, the rule is default construction
Widget w10({});               // third ctor, empty list
std::vector<int> v1(10, 20);  // 10 elements, each of value 20
std::vector<int> v2{10, 20};  // 2 elements, values 10 and 20
                              // is now viewed as an error in the interface design
                              // il overloads overshadows others overloads
                              // in auto type deduction {} is a std:initializer_list

template<typename T, typename... Ts>
void doSomeWork(Ts&&... params) {
    // T - type of objects to create
    // Ts - types of arguments to use
    // we either use parens or braces for parsing
    T localObject(std::forward<Ts>(params)...);
    T localObject{std::forward<Ts>(params)...};
}

std::vector<int> v;
doSomeWork<std::vector<int>>(10, 20);
// for parens, v has 10 elements; for braces, v has 2 elements
// which is correct? only the caller can know!


*** DIFFERENCES BETWEEN 0, NULL, NULLPTR ***
literal 0 is an int, not a pointer
if 0 is used in a context where only a pointer can be used, it'll be interpreted as null pointer, which is a fallback position
the same is true for NULL, yet it is allowed to give it an integral type other than int, especially long
a guideline for C++98 is to avoid overloading on pointer and integral types because of function overload resolution surprises

void f(int);
void f(bool);
void f(void *);
f(0);             // calls f(int)
f(NULL);          // may not compile, otherwise calls f(int)
// if NULL is defined to be 0L than the call is ambiguous
// conversion long -> int, long -> bool, 0L -> void* are equally good

nullptr: a type that can be viewed as a pointer of all types
(1) nullptr does not have integral type nor pointer type
(2) nullptr type is std::nullptr_t
(3) std::nullptr_t is defined to be the type of nullptr
(4) std::nullptr_t implicitly converts to all raw pointer types
(5) overloaded function with nullptr argument always calls the void* overload
(6) preferred to use in templates


*** ALIASES AND TYPEDEFS ***
(1) aliases are possibly easier with function pointers
(2) alias declarations may be templatized (alias templates)

typedef std::unique_ptr<std::unordered_map<std::string, std::string>> UPtrMapSS;
using UPtrMapSS = std::unique_ptr<std::unordered_map<std::string, std::string>>;
typedef void (*FP)(int, const std::string &);
using FP = void (*)(int, const std::string &);


template<typename T>
using MyAllocList = std::list<T, MyAlloc<T>>;
// MyAllocList<Widget> lw;

template<typename T>
struct MyAllocList {
    typedef std::list<T, MyAllocList<T>> type;
};
// MyAllocList<Widget>::type lw;


template<typename T>
class Widget {
private:
    typename MyAllocList<T>::type list;
    // typedef type inside a template must be preceded with typename
    // nested MyAllocList<T>::type is a dependent type
    // ::type may not name a type (there might be a specialization of MyAllocList)
};

template<typename T> using MyAllocList = std::list<T, MyAlloc<T>>;
template<typename T> class Widget {
private:
    MyAllocList<T> list;
    // alias template; typename is neither required nor permitted
    // MyAllocList must name a type, thus MyAllocList<T> is a non-dependent type
};

template<> class MyAllocList<Wine> {
private:
    enum class WineType { White, Red, Rose };
    WineType type;
    // this a MyAllocList template specialization for T=Wine
    // type is a data member, MyAllocList<T>::type inside Widget will refer to it
};


In template metaprogramming (TMP) sometimes there is a need to take template type parameters and create a revised types from them. For example, we want to T=const std::string & turn into std::string. In C++11+ this type of transformations are available as templates and are called type traits. Type traits are implemented as nested typedefs inside templatized structs (reasons for this are historical, Standarization Committee first choose was typedef).
std::remove_const<T>::type               // C++11, const T -> T
std::remove_const_t<T>                   // C++14
std::remove_reference<T>::type           // T&/T&& -> T
std::remove_reference_t<T>
std::add_lvalue_reference<T>::type       // T -> T&
std::add_lvalue_reference_t<T>
std::transformation<T>::type             // C++11 common form
std::transformation_t<T>                 // C++14 alias template


*** SCOPED AND UNSCOPED ENUMS ***
* enum classes reduce namespace pollution by scoping their names (those in braces)
* enum classes are strongly typed (underlying type is int, usually std::size_t), whereas unscoped enums implicitly converts to integral types (usually float or char)
* scoped enums may be forward-declared (no need for enumerators in braces)


enum Color { black, white, red };        // 4 names in the same scope, C++98
auto white = false;                      // ERR, white already declared

enum class Color { black, white, red };  // 3 names scoped to Color, C++11
auto white = false;                      // fine
Color c = white;                         // ERR, white is not declared
auto c = Color::white;                   // fine

auto comparison = c < 14.5;              // OK, for unscoped enum
enum class Status;                       // forward-declaration

enum class Status : std::uint32_t;       // specyfing underlying type
enum Color : std::uint8_t;               // either at declaration or deifinition


template<typename E>
constexpr auto toUType(E enumerator) noexcept {
    // C++14
    return static_cast<std::underlying_type_t<E>>(enumerator);
}

enum class UserInfoFields { uiName, uiEmail, uiReputation };
using UserInfo = std::tuple<std::string, std::string, std::size_t>;
UserInfo uInfo;
auto val = std::get<toUType(UserInfoFields::uiEmail)>(uInfo);


*** DELETED FUNCTIONS VS PRIVATE FUNCTIONS ***
* making new functions public resulting in better error messages (private complains etc.)
* any function may be deleted, while only member functions may be private
* deleted functions can't be used
* deleted functions are taken into consideration during overload resolution
* deleted functions prevent use of a template instantiations that should be disabled


template<class charT, class traits = char_traits<charT>>
class basic_ios : public ios_base {
public:
    basic_ios(const basic_ios&) = delete;
    basic_ios& operator=(const basic_ios&) = delete;
};


bool isLucky(int number);              // we want only ints
bool isLucky(char) = delete;           // reject chars
bool isLucky(bool) = delete;           // reject bools
bool isLucky(double) = delete;         // reject doubles and floats
                                       // C++ prefers the conversion to double

template<typename T> void processPointer(T* ptr);
template<> void processPointer<void>(void*) = delete;
template<> void processPointer<char>(char*) = delete;
template<> void processPointer<const void>(const void*) = delete;
template<> void processPointer<const char>(const char*) = delete;
template<> void processPointer<const volatile void>(const volatile void*) = delete;
template<> void processPointer<const volatile char>(const volatile char*) = delete;
template<> void processPointer<std::wchar_t>(std::wchar_t*) = delete;
template<> void processPointer<std::char16_t>(std::char16_t*) = delete;
template<> void processPointer<std::char32_t>(std::char32_t*) = delete;
template<> void processPointer<std::char8_t>(std::char8_t*) = delete;
// void*, char* (cv-qualified or not)
// std::wchar_t (depending on compiler and target platform, for wide characters)
// std::char16_t (since C++11, UTF-16, 2 bytes, as std::uint_least16_t)
// std::char32_t (since C++11, UTF-32, 4 bytes, as std::uint_least32_t)
// std::char8_t (since C++20, UTF-8, 1 byte, as unsigned char, char, signed char)


*** OVERRIDED FUNCTIONS ***
Requirements for overriding class member functions:
* base class function must be virtual
* base and derived function names must match (except destructors)
* base and derived function parameter types must match
* base and derived function constness must match
* base and derived function return type and exception specification must be compatible
* base and derived function reference qualifiers must be identical (C++11)

Member function reference qualifiers limits use of a member function to lvalues or rvalues only. They need not be virtual to use them.

class Widget {
public:
    void doWork() &;                 // only when *this is an lvalue
    void doWork() &&;                // only when *this is an rvalue
};

Widget w;
w.doWork();                          // calls Widget::doWork() &
Widget makeWidget();
makeWidget().doWork();               // calls Widget::doWork() &&


Contextual keyword override:
* make explicit that a derived class function is supposed to override a base class version
* compiler will kvetch about all the overriding-related problems

Contextual keyword final:
* (applied to a function) prevents function from being overridden in derived class
* (applied to a class) prohibits from being used as a base class


class Base {
public:
    virtual void mf1() const;
    virtual void mf2(int x);
    virtual void mf3() &;
    virtual void mf4() const;
    void mf5() final;
};

class Derived : public Base {
public:
    virtual void mf1() const override;
    virtual void mf2(int x) override;
    virtual void mf3() & override;
    void mf4() const override;
};



*** UNCONDITIONAL NOEXCEPT SPECIFIER ***
* C++98-style exception remain valid, but they're deprecated (specifying exception types)
* it permits compilers to generate better object code (most optimizable function variant)
** optimizers need not keep the runtime stack in an unwindable state if an exception would propagate out of the function, nor must they ensure that objects in a noexcept function are destroyed in the inverse order of construction should an exception leave the function
** this is true only for noexcept specifier
* swapping higher-level data structures can generally be noexcept only if swapping their lower-level constituents is noexcept
* if an exception tries to leave the function in a noexcept function, the program will be terminated
* most functions are exception-neutral, that is they throw no exceptions themselves, but functions they call might emit one; exception-neutral functions are never noexcept, because they may emit 'just passing through' exceptions
* in C++11 all memory deallocation functions and all destructors, both user-defined and compiler-generated, are implicitly noexcept; the destructor is noexcept only if a data member of the class is of a type which specifies 'noexcept(false)'

int f(int x) throw();       // C++98 style; call stack unwounded + actions + termination
int f(int x) noexcept;      // C++11 style; call stack is possibly unwounded + termination


template<class T, size_t N>
void swap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));

template<class T1, class T2>
struct pair {
    void swap(pair& p) noexcept(noexcept(swap(first, p.first)), noexcept(swap(second, p.second)));
}
// STL's std::swap for std::pair


functions with wide contracts: never exhibits undefined behaviors, noexcept-friendly
functions with narrow contracts: if a precondition is violated, results are undefined


*** CONSTEXPR OBJECTS AND FUNCTIONS ***
* conceptually, constexpr indicates a value that's not only constant, it's known during compilation
* constexpr proclaims 'I can be used in a context where C++ requires a constant expression'
* by using constexpr whenever possible, you maximize the range of situations in which your objects and functions may be used
* when applied to objects, it's essentially a beefed-up form of const
** constexpr objects values are determined during translation (compilation + linking)
** values known during compilation may be placed in read-only memory (embedded systems)
** constexpr values can be used in contexts where C++ requires an integral constant expression (array sizes, integral template arguments, enumerator values, alignment specifiers, ...)
** all constexpr objects are const, but not all const objects are constexpr
* when applied to functions, things are more nuanced
** the results of constexpr functions may not be const, nor their values are known during compilation
** constexpr functions produce compile-time constants when they are called with compile-time constants
* I/O statements are generally not permitted in constexpr functions
** if any of the arguments' values is not known during compilation, your code will be rejected (in contexts that demand compile-time constants)
** constexpr function called with one or more values that are not known during compilation, it acts like a normal function, computing its result at runtime
** restrictions imposed upon constexpr functions implementation differ between C++11 and C++14
** in C++11, constexpr functions may contain no more than a single executable return statement, yet ternary operator '?:' and recursion are allowed
** in C++11, constexpr member function cannot modify the object, they are implicitly const, they have void return types which isn't a literal type
** in C++14, constexpr functions are limited to taking and returning literal types, which essentially means types that can have values determined during compilation (all built-in types except void, user-defined class with constexpr constructor)


int sz;
const auto arraySize = sz;
std::array<int, arraySize> data;        // ERROR, arraySize not known during compilation
constexpr auto arraySize2 = 10;
std::array<int, arraySize2> data2;      // OK, arraySize2 is constexpr


constexpr int pow(int base, int exp) noexcept {
    return (exp == 0 ? 1 : base * pow(base, exp - 1));
} // C++11

constexpr int pow(int base, int exp) noexcept {
    auto result = 1;
    for (int i=0; i<exp; ++i) result *= base;
    return result;
} // C++14


class Point {
public:
    constexpr Point(double xVal = 0, double yVal = 0) noexcept : x(xVal), y(yVal) {}
    constexpr double xValue() const noexcept { return x; }
    constexpr double yValue() const noexcept { return y }
    constexpr void setX(double newX) noexcept { x = newX; }
    constexpr void setY(double newY) noexcept { y = newY; }
    
private:
    double x, y;
}; // constexpr setters are allowed in C++14

constexpr Point midpoint(const Point& p1, const Point& p2) noexcept {
    return { (p1.xValue() + p2.xValue()) / 2, (p1.yValue() + p2.yValue()) / 2 };
} // non-member function

constexpr Point reflection(const Point& p) noexcept {
    Point result;
    result.setX(-p.xValue());
    result.setY(-p.yValue());
    return result;
}

constexpr Point p1(9.4, 27.7);
constexpr Point p2(28.8, 5.3);
constexpr auto mid = midpoint(p1, p2);          // compile-time constants
constexpr auto reflectedMid = reflection(mid);  // (-19.1, -16.5) known during compilation


*** CONST MEMBER FUNCTIONS ***
* mutable: permits modification of the class member declared mutable even if the containing object is declared const; mutable is used to specify that the member does not affect the external visible state of the class (mutexes, memo caches, lazy evaluation, ...)
* the safe bet is that const member functions will be a subject to concurrent execution, and that's why you should ensure that yout const member functions are thread safe
* only data that are mutable & shared requires synchronization; unshared & mutable, unshared & immutable, shared & immutable are not a problem

class Polynomial {
public:
    using RootsType = std::vector<double>;
    RootsType roots() const {
        if (!rootsAreValid) { cacheRoots(); rootsAreValid = true; }
        return rootVals;
    }
private:
    mutable bool rootsAreValid{ false };
    mutable RootsType rootVals{};
};
Polynomial p;
auto rootsOfP = p.roots();                      // thread 1
auto valsGivingZero = p.roots();                // thread 2
// data race: reading and writing the same memory without synchronization
// this code has undefined behavior
// the easiest way to address the issue is to employ a mutex
// mutable std::mutex m; as a field & std::lock_guard<std::mutex> g(m); in roots()
// locking and unlocking are non-const operations, thus mutable keyword (also applying M&M rule)
// std::mutex is a move-only type, thus Polynomial with m loses ability to be copy constructed

class Point {
public:
    double distanceFromOrigin() const noexcept {
        ++callCount;
        return std::sqrt((x * x) + (y * y));
    }
private:
    mutable std::atomic<unsigned> callCount{ 0 };
    double x, y;
};
// counting how many times a member function is called
// std::atomics are often a less expensive way to go than std::mutexes


*** SPECIAL MEMBER FUNCTION GENERATION ***
* in official C++ parlance, the special member functions are the ones that C++ is willing to generate on its own; these functions are generated only if they're needed, i.e., if some code uses them without their being expressly declared in the class
* C++98 has four such functions: the default constructor, the destructor, the copy constructor, the copy assignment operator
* C++11 has six such functions: the default constructor, the destructor, the copy constructor, the copy assignment operator, the move constructor, the move assignment operator
** generated special member functions are implicitly public and inline; destructor may be also virtual
** a default constructor is generated only if the class declares no constructor at all
** a destructor is noexcept by default, and is virtual only if a base class destructor is virtual
** a copy constructor is generated only if the class lacks a user-declared copy constructor; deleted if the class declares a move operation; won't be generated in a class with a user-declared copy assignment operator or destructor
** a copy assignment operator is generated only if the class lacks a user-declared copy assignment operator; deleted if the class declares a move operation; won't be generated in a class with a user-declared copy constructor or destructor
** a move constructor and a move assignment operator is generated only if the class contains no user-declared copy operations, move operations, or destructor

* the move operations perform 'memberwise moves' on the non-static data members of the class; they also move-construct its base class parts if they are any; the heart of each 'memberwise' move is application of std::move, that is a member will be moved if it is move-enabled (if it supports move semantics), otherwise it'll be copied
* the move operations are generated when they're needed; the move operations aren't generated if you declare them yourself
* copy operations are independent: copy constructor and copy assignment operator comes together (when both copy operations are treated as defaulted)
* move operations are not independent: if you declare either, that prevents compilers from generating the other; move operations won't be generated for any class that explicitly declares a copy operation
** the rationale is that if you need a custom move constructor, then there's probably something wrong about generated memberwise move assignment operator
** declaring a copy operation declares that the normal approach to memberwise copying an object isn't appropriate for the class; declaring a move operation causes compilers to disable the copy operations by deleting them
** all of this is logical if you think about it, yet this is also about C++98-styled code to behave like in C++98

The Rule of Three states that if you declare any of a copy constructor, copy assignment operator, or destructor, you should declare all three. The justification for this is that almost always copy operation stemmed from the class performing some kind of resource management, which implied that:
* whathever resource management was being done in one copy operation probably needed to be done in the other copy operation
* the class destructor would also be participating in management of the resource, usually releasing it

A consequence of the Rule of Three is that the presence of a user-declared destructor indicates that simple memberwise copy is unlikely to be appropriate for the copying operations in the class. The existence of a user-declared destructor has no impact on compilers' willingness to generate copy operations. That continues to be the case in C++11, but only because restricting the conditions would break too much legacy code (all STL containers declare 'the big three').

So move operations are generated for classes (when needed) only if these three things are true:
* no copy operations are declared in the class
* no move operations are declared in the class
* no destructor is declared in the class

class StringTable {
public:
    StringTable() {}
private:
    std::map<int, std::string> values;
};
// copy & move operations and destructor will automatically be generated if they'll be used
// no user-declared copy operations, thus they'll be implicitly generated
// no explicit copy & move operations, and destructor allows for generated move operations

class StringTable {
public:
    StringTable() { makeLogEntry("Creating StringTable object."); }
    ~StringTable() { makeLogEntry("Destroying StringTable object."); }
private:
    std::map<int, std::string> values;
};
// destructor side effect: it prevents the move operations from being generated
// the class is no longer move-enabled, but move requests will compile and run (as copies)

class StringTable {
public:
    StringTable() { makeLogEntry("Creating StringTable object."); }
    ~StringTable() { makeLogEntry("Destroying StringTable object."); };
    StringTable(StringTable&&) = default;
    StringTable(const StringTable&) = default;
    StringTable& operator=(StringTable&&) = default;
    StringTable& operator=(const StringTable&) = default;
};
// no previous problems
// defaulted default constructor: implicitly defined even if other constructors are present

class Widget {
    template<typename T> Widget(const T& rhs);
    template<typename T> Widget& operator=(const T& rhs);
};
// member function template: construct/assign Widget from anything
// compilers will still generate copy and move operations for Widget beside this templates

class Base {
public:
    explicit Base(int) {}
    virtual ~Base() noexcept = default;         // virtual for polymorphic base class
    Base(Base&&) = default;                     // moving
    Base& operator=(Base&&) = default;          // moving at assignment
    Base(const Base&) = default;                // copying
    Base& operator=(const Base&) = default;     // copying at assignment
};
// The Rule of Five
A constructor with a single non-default parameter (until C++11) that is declared without the function specifier explicit is called a converting constructor. It is said that a converting constructor specifies an implicit conversion from the types of its arguments (if any) to the type of its class. Implicitly-declared and user-defined non-explicit copy constructors and move constructors are converting constructors.


*** STD::UNIQUE_PTR ***
* it's the same as std::auto_ptr but with move semantics that is unavailable in C++98
* by default, std::unique_ptr's are the same size as raw pointers (safe assumption)
* std::unique_ptr embodies exclusive ownership semantics
* a non-null std::unique_ptr always owns what it points to
* copying a std::unique_ptr isn't allowed, because it is a move-only type
* the common use cases for std::unique_ptr's are factory functions and Pimpl Idiom implementation
* there is no indexing operator[] for the single-object form std::unique_ptr<T>, while the array form  std::unique_ptr<T[]> lacks dereferencing operators (operator* and operator->)
** std::unique_ptr<T[]> make sense when you're using a C-like API that returns a raw pointer to a heap array that you assume ownership of
** std::array, std::vector, std::string are virtually always better data structures choices than raw pointers
* if std::unique_ptr is a data member and object is being destroyed, std::unique_ptr would be also destroyed
** if the ownership chain got interrupted due to an exception or other atypical control flow, the std::unique_ptr owning the managed resource would eventually have its destructor called
** if an exception propagates out of a thread's primary function (for the program's initial thread) or if a noexcept specification is violated, local objects may not be destroyed
** if std::abort or an exit function (std::exit, std::quick_exit, std::_Exit) is called, local objects definitely won't be destroyed
* by default, std::unique_ptr destruction would take place via delete, but, during construction, std::unique_ptr objects can be configured to use custom deleters (arbitrary functions, function objects, function pointers)
** custom deleters may change the size of the smart pointer
*** deleters that are function pointers generally cause the size of a std::unique_ptr to grow from one word to two
*** for function object deleters the change in size is the sizeof() that function object
*** stateless function objects (from lambda expressions with no captures) incur no size penalty
** when a custom deleter is to be used, its type must be specified as the second type argument to std::unique_ptr
** for custom deleters objects will ultimately be deleted via a base class pointer, thus, for that to work, the base class must have a virtual destructor
* C++11's smart pointers prohibit implicit conversions from a raw to smart pointer
** to assume ownership of the object created via new we are using reset()
** in templates, each use of new should be perfect-forwarded with std::forward for passed arguments to the function template
* std::unique_ptr easily and efficiently converts to a std::shared_ptr

template<typename... Ts> auto makeInvestment(Ts&&... params) {
    auto delInvmt = [](Investment* pInvestment) {
        makeLogEntry(pInvestment);
        delete pInvestment;
    };
    std::unique_ptr<Investment, decltype(delInvmt)> pInv(nullptr, delInvmt);
    if (stock) { pInv.reset(new Stock(std::forward<Ts>(params)...)); }
    else if (bond) { pInv.reset(new Bond(std::forward<Ts>(params)...)); }
    else if (realEstate) { pInv.reset(new RealEstate(std::forward<Ts>(params)...)); }
    return pInv;
} // C++14; Stock & Bond & RealEstate : Investment

template<typename... Ts> 
std::unique_ptr<Investment, void (*)(Investment*)> makeInvestment(Ts&&... params);
// sizeof(Investment) + sizeof(void (*)(Investment*))

std::shared_ptr<Investment> sp = makeInvestment(arguments);
// implicit conversion to std::shared_ptr




*** ITEMS ***
** Deducing types
Item 01: Understand template type deduction.
Item 02: Understand auto type deduction.
Item 03: Understand decltype.
Item 04: Know how to view deduced types.

** auto
Item 05: Prefer auto to explicit type declarations.
Item 06: Use the explicitly typed initializer idiom when auto deduces undesired types.

** Moving to modern C++
Item 07: Distinguish between () and {} when creating objects.
Item 08: Prefer nullptr to 0 and NULL.
Item 09: Prefer alias declarations to typedefs.
Item 10: Prefer scoped enums to unscoped enums.
Item 11: Prefer deleted functions to private undefined ones.
Item 12: Declare overriding functions override.
Item 13: Prefer const_iterators to iterators.
Item 14: Declare functions noexcept if they won't emit exceptions.
Item 15: Use constexpr whenever possible.
Item 16: Make const member functions thread safe.
Item 17: Understand special member function generation.

** Smart pointers
Item 18: Use std::unique_ptr for exclusive-ownership resource management.



*** THINGS TO REMEMBER ***
** Item 1
* During template type deduction, arguments that are references are treated as non-references, i.e., their reference-ness is ignored.
* When deducing types for universal reference parameters, lvalue arguments get special treatment.
* When deducing types for by-value parameters, const and/or volatile arguments are treated as non-const and non-volatile.
* During template type deduction, arguments that are array or function names decay to pointers, unless they're used to initialize references.

** Item 2
* auto type deduction is usually the same as template type deduction, but auto type deduction assumes that a braced initializer represents a std:initializer_list, and template type deduction doesn't.
* auto in a function return type or a lambda parameter implies template type deduction, not auto type deduction.

** Item 3
* decltype almost always yields the type of a variable or expression without any modifications.
* For lvalue expressions of type T other than names, decltype always reports a type of T&.
* C++14 supports decltype(auto), which, like auto, deduces a type from its initializer, but it performs the type deduction using the decltype rules.

** Item 4
* Deduced types can often be seen using IDE editors, compiler error messages, and the Boost TypeIndex library.
* The results of some tools may be neither helpful nor accurate, so an understanding of C++'s type deduction rules remains essential.

** Item 5
* auto variables must be initialized, are generally immune to type mismatches that can lead to portability or efficiency problems, can ease the process of refactoring, and typically require less typing than variables with explicitly specified types.

** Item 6
* 'Invisible' proxy types can cause auto to deduce the 'wrong' type for an initializing expression.
* The explicitly typed initializer idiom forces auto to deduce the type you want it to have.

** Item 7
* Braced initialization is the most widely usable initialization syntax, it prevents narrowing conversions, and it's immune to C++'s most vexing parse.
* During constructor overload resolution, braced initializers are matched to std::initializer_list parameters if at all possible, even if other constructors offer seemingly better matches.
* An example of where the choice between parentheses and braces can make a significant difference is creating a std::vector<numeric type> with two arguments.
* Choosing between parentheses and braces for object creation inside templates can be challenging.

** Item 8
* Prefer nullptr to 0 and NULL.
* Avoid overloading on integral and pointer types.

** Item 9
* typedef's don't support templatization, but alias declarations do.
* Alias templates avoid the '::type' suffix, and, in templates, the 'typename' prefix often required to refer to typedefs.
* C++14 offers alias templates for all the C++11 type traits transformations.

** Item 10
* C++98-style enums are now known as unscoped enums.
* Enumerators of scoped enums are visible only within the enum. They convert to other types only with a cast.
* Both scoped and unscoped enums support specification of the underlying type. The default underlying type for scoped enums is int. Unscoped enums have no default underlying type.
* Scoped enums may always be forward-declared. Unscoped enums may be forward-declared only if their declaration specifies an underlying type.

** Item 11
* Prefer deleted functions to private undefined ones.
* Any function may be deleted, including non-member functions and template instantiations.

** Item 12
* Declare overriding functions override.
* Member function reference qualifiers make it possible to treat lvalue and rvalue objects (*this) differently.

** Item 13
* Prefer const_iterators to iterators.
* In maximally generic code, prefer non-member versions of begin, end, rbegin, etc., over their member function counterparts.

** Item 14
* noexcept is part of function's interface, and that means that callers may depend on it.
* noexcept functions are more optimizable than non-noexcept functions.
* noexcept is particularly valuable for the move operations, swap, memory deallocation functions, and destructors.
* Most functions are exception-neutral rather than noexcept.

** Item 15
* constexpr objects are const and are initialized with values known during compilation.
* constexpr functions can produce compile-time results when called with arguments whose values are known during compilation.
* constexpr objects and functions may be used in a wider range of contexts than non-constexpr objects and functions.
* constexpr is part of an object's or function's interface.

** Item 16
* Make const member functions thread safe unless you're certain they'll never be used in a concurrent context.
* Use of std::atomic variables may offer better performance than a mutex, but they're suited for manipulation of only a single variable or memory location.

** Item 17
* The special member functions are those compilers may generate on their own: default constructor, destructor, copy operations, and move operations.
* Move operations are generated only for classes lacking explicitly declared move operations, copy operations, and a destructor.
* The copy constructor is generated only for classes lacking an explicitly declared copy constructor, and it's deleted if a move operation is declared. The copy assignment operator is generated only for classes lacking an explicitly declared copy assignment operator, and it's deleted if a move operation is declared. Generation of the copy operations in classes with an explicitly declared destructor is deprecated.
* Member function templates never suppress generation of special member functions.

** Item 18
* std::unique_ptr is a small, fast, move-only smart pointer for managing resources with exclusive-ownership semantics.
* By default, resource destruction takes place via delete, but custom deleters can be specified. Stateful deleters and function pointers as deleters increase the size of std::unique_ptr objects.
* Converting a std::unique_ptr to a std::shared_ptr is easy.


